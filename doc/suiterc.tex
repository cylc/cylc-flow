\section{Suite.rc Reference}
\label{SuiteRCReference}

\lstset{language=bash}

This appendix defines all legal suite definition config items.
Embedded Jinja2 code (see Section~\ref{Jinja2}) must process to a valid 
raw suite.rc file. See also Section~\ref{SuiteRCFile} for a descriptive
overview of suite.rc files, including syntax (Section~\ref{Syntax}).

\subsection{Top Level Items}

The only top level configuration items at present are the suite title
and description.

\subsubsection{title}

A single line description of the suite. It is displayed in the db viewer 
window and can be retrieved at run time with the
\lstinline=cylc show= command.

\begin{myitemize}
\item {\em type:} single line string
\item {\em default:} ``No title provided''
\end{myitemize}

\subsubsection{description}

A multi-line description of the suite. It can be retrieved by the db viewer 
right-click menu, or at run time with the \lstinline=cylc show= command.

\begin{myitemize}
\item {\em type:} multi-line string
\item {\em default:} ``No description provided''
\end{myitemize}

\subsection{[cylc]}

This section is for configuration that is not specifically task-related.

\subsubsection[required run mode]{ [cylc] $\rightarrow$ required run mode}

If this item is set cylc will abort if the suite is not started in the
specified mode. This can be used for demo suites that have to be
run in simulation mode, for example, because they have been taken out of
their normal operational context; or to prevent accidental submission of
expensive real tasks during suite development. 
\begin{myitemize}
    \item {\em type:} string
    \item {\em legal values:} live, dummy, simulation 
    \item {\em default:} None 
\end{myitemize}

\subsubsection[UTC mode]{ [cylc] $\rightarrow$ UTC mode}

Cylc runs off the suite host's system clock by default. This item allows
you to run the suite in UTC even if the system clock is set to local time.
Clock-triggered tasks will trigger when the current UTC time is equal to
their cycle time plus offset; other time values used, reported, or
logged by cylc will also be in UTC. 

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False 
\end{myitemize}


\subsubsection[abort if any task fails]{[cylc] $\rightarrow$ abort if any task fails}

Cylc does not normally abort if tasks fail, but if this item is turned
on it will abort with exit status 1 if any task fails.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[log resolved dependencies]{[cylc] $\rightarrow$ log resolved dependencies}

If this is turned on cylc will write the resolved dependencies of each
task to the suite log as it becomes ready to run (a list of the IDs of
the tasks that actually satisfied its prerequisites at run time). Mainly
used for cylc testing and development.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[{[[}job submission{]]}]{[cylc] $\rightarrow$ [[job submission]]}

Tasks ready to submit are now queued for processing in a background
worker thread, so submitting a lot of tasks at once does not hold cylc 
back.  In the job submission thread tasks are are batched, with members
of each batch being submitted in parallel. Batches are processed serially, 
with a delay between batches, to avoid swamping the host system with too
many simultaneous job submissions. 

The time required for a single task's job submission to complete
typically depends on whether it is a remote task (for which an ssh
connection must be established and used) and whether dynamic host
selection is used (see~\ref{DynamicHostSelection} (a dynamic host
selection command runs as part of the job submission command). The time
taken for a batch of parallel job submissions to complete will be
roughly the duration of the slowest member process. 

\paragraph[batch size]{[cylc] $\rightarrow$ [[job submission]] $\rightarrow$ batch size}

The maximum number of tasks to be submitted in a single batch, in the
job submission thread. Cylc waits for all batch member job-submissions
to complete before proceeding to the next batch.

\begin{myitemize}
    \item {\em type:} integer (minimum 1)
    \item {\em default:} 10
\end{myitemize}

\paragraph[delay between batches]{[cylc] $\rightarrow$ [[job submission]] $\rightarrow$ delay between batches}

It may cause a problem for some batch queue schedulers to submit too
many jobs at once, so cylc allows a configurable delay between job 
submission batches.

\begin{myitemize}
    \item {\em type:} integer seconds (minimum 0)
    \item {\em default:} 0
\end{myitemize}

\subsubsection[{[[}poll and kill command submission{]]}]{[cylc] $\rightarrow$ [[poll and kill command submission]]}

Task poll and kill commands are queued to a worker thread that processes
them in parallel, in batches to limit the number that can execute at
once.

\paragraph[batch size]{[cylc] $\rightarrow$ [[poll and kill command submission]] $\rightarrow$ batch size}

The maximum number of poll and kill commands to execute at once, before
moving on to the next batch.

\begin{myitemize}
    \item {\em type:} integer (minimum 1)
    \item {\em default:} 10
\end{myitemize}

\paragraph[delay between batches]{[cylc] $\rightarrow$ [[poll and kill command submission]] $\rightarrow$ delay between batches}

How long to wait, in seconds, before processing the next batch of poll and kill commands. 

\begin{myitemize}
    \item {\em type:} integer seconds (minimum 0)
    \item {\em default:} 0
\end{myitemize}


\subsubsection[{[[}event handler submission{]]}]{[cylc] $\rightarrow$ [[event handler submission]]}

Task event handlers are queued to a worker thread that processes them in
parallel, in batches to limit the number that can execute at once ({\em
suite event handlers}, on the other hand, are executed as background
sub-processes in the main thread, not queued to the task
event handler thread).

\paragraph[batch size]{[cylc] $\rightarrow$ [[event handler submission]] $\rightarrow$ batch size}

The maximum number of event handlers to execute at once, before moving
on to the next batch.

\begin{myitemize}
    \item {\em type:} integer (minimum 1)
    \item {\em default:} 10
\end{myitemize}

\paragraph[delay between batches]{[cylc] $\rightarrow$ [[event handler submission]] $\rightarrow$ delay between batches}

How long to wait, in seconds, before processing the next batch of event handlers. 

\begin{myitemize}
    \item {\em type:} integer seconds (minimum 0)
    \item {\em default:} 0
\end{myitemize}

\subsubsection[{[[}event hooks{]]}]{[cylc] $\rightarrow$ [[event hooks]]}
\label{SuiteEventHandling}

Cylc has internal ``hooks'' to which you can attach handlers that are 
called {\em by cylc} whenever certain events occur. This section
configures suite event hooks; see Section~\ref{TaskEventHandling} for
task event hooks.

Event handlers can send an email or an SMS, call a pager, intervene in
the operation of their own suite, or whatever.
They can be held in the suite bin directory, otherwise it is up to you
to ensure their location is in \lstinline=$PATH= (in the shell in which
cylc runs, on the suite host).
\lstinline=cylc [hook] email-suite= is a simple suite event handler.

Suite event handlers are called by cylc with the following arguments:
\begin{lstlisting}
<suite-event-handler> EVENT SUITE MESSAGE
\end{lstlisting}
where,
\begin{myitemize}
    \item EVENT - event name (see below)
    \item SUITE - suite name
    \item MESSAGE - describes what has happened.
\end{myitemize}

Additional information can be passed to event handlers via 
[cylc] $\rightarrow$ [[environment]].

\paragraph[EVENT handler]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ EVENT handler}

Specify a handler script to call when one of the following EVENTs occurs:
\begin{myitemize}
    \item {\bf startup}  - the suite has started running 
    \item {\bf shutdown} - the suite is shutting down
    \item {\bf timeout}  - the suite has timed out
\end{myitemize}

Item details:
\begin{myitemize}
    \item {\em type:} string (event handler script name)
    \item {\em default:} None
    \item {\em example:} \lstinline@startup handler = my-handler.sh@
\end{myitemize}

\paragraph[timeout]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ timeout}

If a timeout is set and the timeout event is handled, the timeout event
handler will be called if the suite times out before it finishes.
The timer is set initially at suite start up. 

\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} (none)
\end{myitemize}

\paragraph[reset timer]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ reset timer}

If \lstinline=True= (the default) the suite timer will continually reset
after any task changes state, so you can time out after some interval
since the last activity occured rather than on absolute suite execution
time.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} True
\end{myitemize}

\paragraph[abort on timeout]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ abort on timeout}

If a suite timer is set (above) this will cause the suite to abort with
error status if the suite times out while still running.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[abort if startup handler fails]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ abort if EVENT handler fails}

Cylc does not normally care whether an event handler succeeds or fails,
but if this is turned on the EVENT handler will be executed in the
foreground (which will block the suite while it is running) and the
suite will abort if the handler fails.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[{[[}lockserver{]]}]{[cylc] $\rightarrow$ [[lockserver]]}

The cylc lockserver brokers suite and task locks on the network (these
are somewhat analagous to traditional local {\em lock files}). It
prevents multiple instances of a suite or task from being invoked 
at the same time (via scheduler instances or \lstinline=cylc submit=).
 
See \lstinline=cylc lockserver --help= for 
how to run the lockserver, and \lstinline=cylc lockclient --help= for 
occasional manual lock management requirements. 

\paragraph[enable]{[cylc] $\rightarrow$ [[lockserver]] $\rightarrow$ enable}

The lockserver is currently disabled by default. It is intended mainly for
operational use.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[simultaneous instances]{[cylc] $\rightarrow$ [[lockserver]] $\rightarrow$ simultaneous instances}

By default the lockserver prevents multiple simultaneous instances of a
suite from running even under different registered names. But allowing
this may be desirable if the I/O paths of every task in the suite are
dynamically configured to be suite specific (and similarly for the suite
state dump and logging directories, by using suite identity variables in
their directory paths). Note that {\em the lockserver cannot protect you
from running multiple distinct {\bf copies} of a suite simultaneously}. 

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[{[[}environment{]]} ]{[cylc] $\rightarrow$ [[environment]]}

Variables defined here are exported into the environment in which cylc
itself runs. They are then available to {\em local processes spawned
directly by cylc}. Any variables read by task event handlers must be
defined here, for instance, because event handlers are executed
directly by cylc, not by running tasks. And similarly the {command
lines} issued by cylc to invoke event handlers or to submit task 
job scripts could, in principle, make use of environment variables
defined here. 
\paragraph{Warnings}

\begin{myitemize}
    \item Cylc local variables are not available to
        executing tasks unless you happen to choose a local direct job
        submission method.  {\em Always use task runtime environments to
        pass variables into the task execution environment
        (\ref{AppendixTaskExecutionEnvironment}).}
    \item Unlike task execution environment variables, which are written
        to job scripts and interpreted by the shell at run time, 
        cylc local environment variables are written directly 
        to the environment by Python as literal strings {\em  so 
        shell variable expansion expressions cannot be used here.}
\end{myitemize}

\paragraph[\_\_VARIABLE\_\_ ]{[cylc] $\rightarrow$ [[environment]] $\rightarrow$ \_\_VARIABLE\_\_}

Replace \_\_VARIABLE\_\_ with any number of environment variable
assignment expressions.
Values may refer to other local environment variables (order of
definition is preserved) and are not evaluated or manipulated by 
cylc, so any variable assignment expression that is legal in the 
shell in which cylc is running can be used (but see the warning 
above on variable expansions, which will not be evaluated).
White space around the `$=$' is allowed (as far as cylc's suite.rc 
parser is concerned these are normal configuration items).

\begin{myitemize}
    \item {\em type:} string
    \item {\em default:} (none)
    \item {\em examples:} 
        \begin{myitemize}
            \item \lstinline@FOO = $HOME/foo@
        \end{myitemize}
\end{myitemize}

\subsubsection[{[[}accelerated clock{]]}]{[cylc] $\rightarrow$ [[accelerated clock]] }
\label{ClockConfig}

Accelerated clock settings, used to speed up the wait between cycles in
the simulation and dummy run modes. 

\paragraph[disable]{[cylc] $\rightarrow$ [[accelerated clock]] $\rightarrow$ disable}

Disabling the accelerated clock makes the suite (and its log time stamps
etc.) run on real time. Note that if the suite has clock-triggered tasks
that catch up to the wall clock, the interval between cycles will also be
in real time - e.g.\ six hours for a six hourly cycle.

\begin{myitemize}
    \item {\em type:} boolean 
    \item {\em default:} False
\end{myitemize}


\paragraph[rate]{[cylc] $\rightarrow$ [[accelerated clock]] $\rightarrow$ rate}

The rate at which the accelerated clock runs in real seconds per
simulated hour.

\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, real seconds per simulated hour)
    \item {\em default:} $10$
\end{myitemize}

\paragraph[offset]{[cylc] $\rightarrow$ [[accelerated clock]] $\rightarrow$ offset}

The clock offset determines the initial time on the accelerated clock, 
at suite startup, relative to the initial cycle time. An offset of
$0$ simulates real time operation; greater offsets simulate catch up
from a delay and subsequent transition to real time operation.

\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, hours behind initial cycle time)
    \item {\em default:} $24$
\end{myitemize}


\subsubsection[{[[}reference test{]]}]{[cylc] $\rightarrow$ [[reference test]] }
\label{ReferenceTestConfig}

Reference tests are finite-duration suite runs that abort with non-zero
exit status if cylc fails, if any task fails, if the suite times
out, or if a shutdown event handler that (by default) compares the test
run with a reference run reports failure. See {\em Automated Reference Test
Suites}, Section~\ref{AutoRefTests}.

\paragraph[suite shutdown event handler]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ suite shutdown event handler}

A shutdown event handler that should compare the test run with the
reference run, exiting with zero exit status only if the test run
verifies.

\begin{myitemize}
    \item {\em type:} string (event handler command name or path)
    \item {\em default:} \lstinline=cylc hook check-triggering=
\end{myitemize}
As for any event handler, the full path can be ommited if the script is
located somewhere in \lstinline=$PATH= or in the suite bin directory.

\paragraph[required run mode]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ required run mode}

If your reference test is only valid for a particular run mode, this
setting will cause cylc to abort if a reference test is attempted 
in another run mode.

\begin{myitemize}
    \item {\em type:} string
    \item {\em legal values:} live, dummy, simulation
    \item {\em default:} None
\end{myitemize}

\paragraph[allow task failures]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ allow task failures}

A reference test run will abort immediately if any task fails, unless
this item is set, or a list of {\em expected task failures} is provided
(below).

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[expected task failures]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ expected task failures}

A reference test run will abort immediately if any task fails, unless
{\em allow task failures} is set (above) or the failed task is found 
in a list IDs of tasks that are expected to fail.

\begin{myitemize}
    \item {\em type:} list of strings (task IDs: \lstinline=name.tag=)
    \item {\em default:} (none)
    \item {\em example:} \lstinline=foo.20120808, bar.20120908=
\end{myitemize}

\paragraph[live mode suite timeout]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ live mode suite timeout}

The timeout value in minutes after which the test run should be aborted
if it has not finished, in live mode. Test runs cannot be done in live
mode unless you define a value for this item, because it is not possible
to arrive at a sensible default for all suites.

\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} None
\end{myitemize}

\paragraph[simulation mode suite timeout]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ simulation mode suite timeout}

The timeout value in minutes after which the test run should be aborted
if it has not finished, in simulation mode. Test runs cannot be done in
simulation mode unless you define a value for this item, because it is
not possible to arrive at a sensible default for all suites.

\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} None
\end{myitemize}

\paragraph[dummy mode suite timeout]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ dummy mode suite timeout}

The timeout value in minutes after which the test run should be aborted
if it has not finished, in dummy mode.  Test runs cannot be done in
dummy mode unless you define a value for this item, because it is not
possible to arrive at a sensible default for all suites.

\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} None
\end{myitemize}


\subsection{[scheduling]}

This section allows cylc to determine when tasks are ready to run.

\subsubsection[initial cycle time]{[scheduling] $\rightarrow$ initial cycle time}

At startup each cycling task (unless specifically excluded under
[special tasks]) will be inserted into the suite with this cycle time,
or with the closest subsequent valid cycle time for the task. Note that
whether or not {\em cold-start tasks}, specified under [special tasks],
are inserted, and in what state they are inserted, depends on the start
up method - cold, warm, or raw.  If this item is provided you can 
override it on the command line or in the gcylc suite start panel.

\begin{myitemize}
    \item {\em type:} integer (YYYY[MM[DD[HH[mm[ss]]]]])
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[final cycle time]{[scheduling] $\rightarrow$ final cycle time}

Cycling tasks are held once they pass the final cycle time, if one is
specified. Once all tasks have achieved this state the suite will shut
down. If this item is provided you can override it on the command line
or in the gcylc suite start panel.

\begin{myitemize}
    \item {\em type:} integer (YYYY[MM[DD[HH[mm[ss]]]]])
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[runahead limit]{[scheduling] $\rightarrow$ runahead limit}

The suite runahead limit prevents the fastest tasks in a suite from
getting too far ahead of the slowest ones, as documented in
Section~\ref{RunaheadLimit}. Tasks exceeding the limit are put into
a special runahead held state until slower tasks have caught up
sufficiently. 
\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, hours)
    \item {\em default:} (twice the minimum cycling interval in the suite)
\end{myitemize}

\subsubsection[{[[}queues{]]}]{[scheduling] $\rightarrow$ [[queues]]}

Configuration of internal queues, by which the number of simultaneously
active tasks (submitted or running) can be limited, per queue. By
default a single queue called {\em default} is defined, with all tasks 
assigned to it and no limit. To use a single queue for the whole suite 
just set the limit on the {\em default} queue as required.
See also Section~\ref{InternalQueues}.

\paragraph[{[[[}\_\_QUEUE\_\_{]]]}]{[scheduling] $\rightarrow$ [[queues]] $\rightarrow$ [[[\_\_QUEUE\_\_]]]}

Section heading for configuration of a single queue. Replace
\_\_QUEUE\_\_ with a queue name, and repeat the section as required.

\begin{myitemize}
\item {\em type:} string
\item {\em default:} ``default''
\end{myitemize}

\paragraph[limit]{[scheduling] $\rightarrow$ [[queues]] $\rightarrow$ [[[\_\_QUEUE\_\_]]] $\rightarrow$ limit}

The maximum number of active tasks allowed at any one time, for this queue.
\begin{myitemize}
\item {\em type:} integer
\item {\em default:} 0 (i.e.\ no limit)
\end{myitemize}

\paragraph[members]{[scheduling] $\rightarrow$ [[queues]] $\rightarrow$ [[[\_\_QUEUE\_\_]]] $\rightarrow$ members}

A list of member tasks, or task family names, to assign to this queue
(assigned tasks will automatically be removed from the default queue).
\begin{myitemize}
\item {\em type:} list of strings
\item {\em default:} none for user-defined queues; all tasks for the ``default'' queue
\end{myitemize}

\subsubsection[{[[}special tasks{]]}]{[scheduling] $\rightarrow$ [[special tasks]]}

This section is used to identify any tasks with several kinds of special
behaviour. By default (i.e.\ non ``special'' behaviour) tasks submit (or
queue) as soon as their prerequisites are satisfied, and they spawn a
successor as soon as they enter the submitted state.\footnote{Spawning
any earlier than this brings no advantage in terms of functional
parallelism and would cause uncontrolled proliferation of waiting
tasks.}  Family names used here are interpreted purely as shorthand for
the list of all member tasks. A sequential family, therefore, is a
family of sequential tasks, not a family that behaves ``sequentially''
as a whole.

\paragraph[clock-triggered]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ clock-triggered}

Clock-triggered tasks wait on a wall clock time specified as an offset
{\em in hours} relative to their own cycle time, in addition to any
dependence they have on other tasks. Generally speaking, only tasks that
wait on external real time data need to be clock-triggered.  Note that
in computing the trigger time the full wall clock time and cycle time
are compared, not just hours and minutes of the day, so when running a
suite in catchup/delayed operation, or over historical periods,
clock-triggered tasks will not constrain the suite at all until they
catch up to the wall clock.

\begin{myitemize}
    \item {\em type:} list of tasknames with offsets (hours, positive or negative)
    \item {\em default:} (none)
    \item {\em example:} \lstinline@clock-triggered = foo(1.5), bar(2.25)@
\end{myitemize}

\paragraph[start-up]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ start-up}

Start-up tasks are one-off tasks (they do not spawn a successor) that
only run in the first cycle (and only in a cold-start) and any
dependence on them is ignored in subsequent cycles. They can be used to
prepare a suite workspace, for example, before other tasks run. Start-up
tasks cannot appear in conditional trigger expressions with normal
cycling tasks, because the meaning of the conditional expression becomes
undefined in subsequent cycles. 

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[cold-start]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ cold-start}

A cold-start task is one-off task used to satisfy the dependence of an
associated task with the same cycle time, on outputs from a previous
cycle - when those outputs are not available.  The primary use for this
is to cold-start a warm-cycled forecast model that normally depends on
restart files (e.g.\ model background fields) generated by its previous
forecast, when there is no previous forecast.  This is required when
cold-starting the suite, but cold-start tasks can also be inserted into
a running suite to restart a model that has had to skip some cycles
after running into problems. Cold-start tasks can invoke real cold-start
processes, or they can just be dummy tasks that represent some external
process that has to be completed before the suite is started. Unlike
{\em start-up} tasks, dependence on cold-start tasks is preseverved in
subsequent cycles so they must typically be used in OR'd conditional
expressions to avoid holding up the suite.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[sequential]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ sequential}

By default, a task spawns a successor as soon as it is submitted to run
so that successive instances of the same task can run in parallel if the
opportunity arises (i.e.\ if their prerequisites happen to be satisfied
before their predecessor has finished). {\em Sequential tasks}, however,
will not spawn a successor until they have finished successfully. This
should be used for (a) {\em tasks that cannot run in parallel with their
own previous instances} because they would somehow interfere with each
other (use cycle time in all I/O paths to avoid this); and (b) {\em warm
cycled forecast models that write out restart files for multiple cycles
ahead} (exception: see ``explicit restart outputs''
below).\footnote{This is because you don't want Model[T] waiting around
to trigger off Model[T-12] if Model[T-6] has not finished yet. If Model
is forced to be sequential this can't happen because Model[T] won't
exist in the suite until Model[T-6] has finished. But if Model[T-6]
fails, it can be spawned-and-removed from the suite so that Model[T] can
{\em then} trigger off Model[T-12], which is the correct behaviour.} 

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[one-off]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ one-off}

Synchronous one-off tasks have an associated cycle time but do not spawn
a successor. Synchronous {\em start-up} and {\em cold-start} tasks are
automatically one-off tasks and do not need to be listed here.
Dependence on one-off tasks is not restricted to the first cycle.

\begin{myitemize}
\item {\em type:} list of task names
\item {\em default:} (none)
\end{myitemize}

\paragraph[explicit restart outputs]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ explicit restart outputs}

% TODO - THESE TASKS COULD BE IDENTIFIED FROM THE GRAPH?

This is only required in the event that you need a warm cycled forecast
model to start at the instant its restart files are ready (if other
prerequisites are satisfied) {\em even if its previous instance has
not finished yet}.  If so, the model task has to depend on special
output messages emitted by the previous instance as soon as its restart
files are ready, instead of just on the previous instance finishing.
{\em Tasks in this category must define special restart
output messages containing the word ``restart''}, in
[runtime] $\rightarrow$ [[TASK]] $\rightarrow$ [[[outputs]]] - see
Section~\ref{RIOC}.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[exclude at start-up]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ exclude at start-up}
\label{EASU}

Any task listed here will be excluded from the initial task pool (this
goes for suite restarts too). If an {\em inclusion} list is also
specified, the initial pool will contain only included tasks that have
not been excluded. Excluded tasks can still be inserted at run time.
Other tasks may still depend on excluded tasks if they have not been
removed from the suite dependency graph, in which case some manual
triggering, or insertion of excluded tasks, may be required.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[include at start-up]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ include at start-up}
\label{IASU}

If this list is not empty, any task {\em not} listed in it will be
excluded from the initial task pool (this goes for suite restarts too).
If an {\em exclusion} list is also specified, the initial pool will
contain only included tasks that have not been excluded. Excluded tasks
can still be inserted at run time. Other tasks may still depend on
excluded tasks if they have not been removed from the suite dependency
graph, in which case some manual triggering, or insertion of excluded 
tasks, may be required.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[{[[}dependencies{]]}]{[scheduling] $\rightarrow$ [[dependencies]]}

The suite dependency graph is defined under this section.  You can plot
the dependency graph as you work on it, with \lstinline=cylc graph= or
by right clicking on the suite in the db viewer.  See also 
Section~\ref{ConfiguringScheduling}.

\paragraph[graph]{ [scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ graph }

The dependency graph for any one-off asynchronous (non-cycling) tasks in
the suite goes here. This can be used to construct a suite of one-off
tasks (e.g.\ build jobs and related processing) that just completes and
then exits, or an initial suite section that completes prior to the
cycling tasks starting (if you make the first cycling tasks depend on
the last one-off ones). But note that synchronous {\em start-up} tasks
can also be used for the latter purpose.  See Section~\ref{GraphDescrip}
below for graph string syntax, and Section~\ref{ConfiguringScheduling}.
\begin{myitemize}
    \item {\em type:} string 
    \item {\em example:} (see Section~\ref{GraphDescrip} below)
\end{myitemize}
 
\paragraph[{[[[}\_\_VALIDITY\_\_{]]]}]{[scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ [[[\_\_VALIDITY\_\_]]]}

\_\_VALIDITY\_\_ section headings define the sequence of cycle times for
which the subsequent graph section is valid. For cycling tasks use a
comma-separated list of integer hours, $0\leq H \leq 23$ for the original 
hours-of-the-day cycling, or reference a particular stepped daily,
monthly, or yearly cycling module:
\begin{myitemize}
    \item {\em examples:} 
        \begin{myitemize} 
            \item hours-of-the-day cycling: \lstinline@[[[0,6,12,18]]]@ or \lstinline@[[[HoursOfTheDay(0,6,12,18)]]]@ 
            \item stepped daily cycling: \lstinline@[[[Daily(20100823,2)]]]@ 
            \item stepped monthly cycling: \lstinline@[[[Monthly(201008,2)]]]@ 
            \item stepped yearly cycling: \lstinline@[[[Yearly(2010,2)]]]@ 
        \end{myitemize}
    \item {\em default:} (none)
\end{myitemize}
For repeating asynchronous tasks put `ASYNCID:{\em pattern}' in the
section heading, where {\em pattern} is a regular expression that
matches an asynchronous task ID:
\begin{myitemize}
    \item {\em examples:} 
        \begin{myitemize} 
            \item repeating asynchronous tasks: \lstinline@[[ASYNCID:SAT-\d+]]@ 
        \end{myitemize}
    \item {\em default:} (none)
\end{myitemize}

See Section~\ref{GraphTypes}, {\em Graph Types} for the meaning of the
stepped cycler arguments, how multiple graph sections combine within a
single suite, and so on.

\subparagraph[graph]{[scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ [[[\_\_VALIDITY\_\_]]] $\rightarrow$ graph }
\label{GraphDescrip}

The dependency graph for the specified validity section (described just
above) goes here. Syntax examples follow; see also
Sections~\ref{ConfiguringScheduling} ({\em Configuring Scheduling})
and~\ref{TriggerTypes} ({\em Trigger Types}). 

\begin{myitemize}
\item {\em type:} string 
\item {\em examples:}
  \begin{lstlisting}
graph = """
   foo => bar => baz & waz   # baz and waz both trigger off bar
   baz:out1 => faz           # faz triggers off an internal output of baz
   ColdFoo | foo[T-6] => foo # cold-start or restart for foo
   X:start => Y              # Y triggers if X starts executing
   X:fail => Y               # Y triggers if X fails
   foo[T-6]:fail => bar      # bar triggers if foo[T-6] fails
   X => !Y                   # Y suicides if X succeeds
   X | X:fail => Z           # Z triggers if X succeeds or fails
   X:finish => Z             # Z triggers if X succeeds or fails
   (A | B & C ) | D => foo   # general conditional triggers
   foo:submit => bar         # bar triggers if foo is successfully submitted
   foo:submit-fail => bar    # bar triggers if submission of foo fails
   # comment
   """
  \end{lstlisting}
\item {\em default:} (none)
\end{myitemize}

\subparagraph[daemon]{[scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ [[[\_\_VALIDITY\_\_]]] $\rightarrow$ daemon }

For [[[ASYNCID:pattern]]] validity sections only, list 
{\em asynchronous daemon} tasks by name. This item is located here rather than
under [scheduling] $\rightarrow$ [[special tasks]] because a damon task
is associated with a particular asynchronous ID.

\begin{myitemize}
\item {\em type:} list of task names
\item {\em default:} (none)
\end{myitemize}

\subsection{[runtime]}

This section is used to specify how, where, and what to execute when
tasks are ready to run. Common
configuration can be factored out in a multiple-inheritance hierarchy of
runtime namespaces that culminates in the tasks of the suite. Order of
precedence is determined by the C3 linearization algorithm as used to
find the {\em method resolution order} in Python language class
hiearchies. For details and examples see Section~\ref{NIORP}, {\em
Runtime Properties}.

\subsubsection[{[[}\_\_NAME\_\_{]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]]}

Replace \_\_NAME\_\_ with a namespace name, or a comma separated list of
names, and repeat as needed to define all tasks in the suite. Names may
contain letters, digits, underscores, and hyphens. A namespace
represents a group or family of tasks if other namespaces inherit from
it, or a task if no others inherit from it.

%Names may not contain colons (which would preclude use of directory paths
%involving the registration name in \lstinline=$PATH= variables). They 
%may not contain the `.' character (it will be interpreted as the
%namespace hierarchy delimiter, separating groups and names -huh?). 

\begin{myitemize}
\item {\em legal values:} 
    \begin{myitemize}
        \item \lstinline=[[foo]]=
        \item \lstinline=[[foo, bar, baz]]=
    \end{myitemize}
\end{myitemize}

If multiple names are listed the subsequent settings apply to each. 

All namespaces inherit initially from {\em root}, which can be
explicitly configured to provide or override default settings
for all tasks in the suite.

\paragraph[inherit]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ inherit}

A list of the immediate parent(s) this namespace inherits from. If no
parents are listed \lstinline=root= is assumed.

\begin{myitemize}
\item {\em type:} comma-separated list of strings (other namespace names)
\item {\em default:} \lstinline=root=
\end{myitemize}

\paragraph[title]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ title}

A single line description of this namespace. It is displayed by the
\lstinline=cylc list= command and can be retrieved from running tasks
with the \lstinline=cylc show= command.

\begin{myitemize}
\item {\em type:} single line string 
\item {\em root default:} ``No title provided''
\end{myitemize}

\paragraph[description]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ description}

A multi-line description of this namespace, retrievable from running tasks with the 
\lstinline=cylc show= command.

\begin{myitemize}
\item {\em type:} multi-line string 
\item {\em root default:} ``No description provided''
\end{myitemize}


\paragraph[initial scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ initial scripting}

Initial scripting is executed at the top of the task job script just
before the \lstinline=cylc task started= message call is made, and
before the task execution environment is configured - so it does not
have access to any suite or task environment variables.  The original
intention was to allow remote tasks to source login scripts before
calling the first cylc command, e.g.\ to set \lstinline=$PYTHONPATH= if
Pyro has been installed locally. Note however that the remote task
invocation mechanism now automatically sources both
\lstinline=/etc/profile= and \lstinline=$HOME/.profile= if they exist. 
For other uses pre-command scripting should be used if possible because
it can has access to the task execution environment.
\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\item {\em example:} \lstinline@initial scripting = "echo Hello World"@
\end{myitemize}

\paragraph[environment scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ environment scripting}

Environment scripting is inserted into the task job script between
the cylc-defined environment (suite and task identity, etc.) and the 
user-defined task runtime environment - i.e.\ it has access to the 
cylc environment, and the task environment has access to the results of
this scripting.
\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\item {\em example:} \lstinline@environment scripting = "echo Hello World"@
\end{myitemize}

\paragraph[command scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ command scripting}

The scripting to execute when the associated task is ready to run - this
can be a single command or multiple lines of scripting. 

\begin{myitemize}
\item {\em type:} string
\item {\em root default:} \lstinline=echo "Default command scripting"; sleep 10=
\end{myitemize}


\paragraph[pre-command scripting]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ pre-command scripting}

Scripting to be executed immediately {\em before} the command scripting.
This would typically be used to add scripting to every task in a family
(for individual tasks you could just incorporate the extra commands into
the main command scripting). See also {\em post-command scripting},
below.

\begin{myitemize}
\item {\em type:} string, or a list of strings
\item {\em default:} (none)
\item {\em example:} 
 \begin{lstlisting}
    pre-command scripting = """
      . $HOME/.profile
      echo Hello from suite ${CYLC_SUITE_REG_NAME}!"""
 \end{lstlisting}
\end{myitemize}

\paragraph[post-command scripting]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ post-command scripting}

Scripting to be executed immediately {\em after} the command scripting.
This would typically be used to add scripting to every task in a family
(for individual tasks you could just incorporate the extra commands into
the main command scripting). See also {\em pre-command scripting},
above.

\begin{myitemize}
\item {\em type:} string, or a list of strings
\item {\em default:} (none)
\end{myitemize}

\paragraph[retry delays]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ retry delays}
\label{RefRetries}

A list of time intervals in minutes, after which to resubmit the task if
it fails. The variable \lstinline=$CYLC_TASK_TRY_NUMBER= in the task
execution environment is incremented each time, starting from 1 for the
first try - this can be used to vary task behavior by try number. 

\begin{myitemize}
\item {\em type:} list of floats, optionally {\em preceded} by multipliers
\item {\em example:} \lstinline=1.5,3*10= is equivalent to \lstinline=1.5,10,10,10=
\item {\em root default:} (none)
\end{myitemize}

\paragraph[submission polling intervals]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ submission polling intervals}
\label{SubmissionPollingIntervals}

A list of intervals, in minutes, with optional multipliers, after which
cylc will poll for status while the task is in the submitted state.

For the polling task communications method this overrides the default
submission polling interval in the site/user config files
(Section~\ref{SiteAndUserConfiguration}). For pyro and ssh task communications
polling is not done by default but it can still be configured here as a
regular check on the health of submitted tasks.

Each list value is used in turn until the last, which is used repeatedly 
until finished.

{\em Detaching tasks cannot be polled or killed by cylc - 
see Section~\ref{DetachingTasks}.}

\begin{myitemize}
\item {\em type:} list of floats, optionally {\em preceded} by multipliers
\item {\em example:} \lstinline=1,3*10,1= is equivalent 
        to \lstinline=1,10,10,10,1=
\item {\em root default:} (none)
\end{myitemize}
A single interval value is probably appropriate for submission polling.

\paragraph[execution polling intervals]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ execution polling intervals}
\label{ExecutionPollingIntervals}

A list of intervals, in minutes, with optional multipliers, after which
cylc will poll for status while the task is in the running state.

For the polling task communications method this overrides the default
execution polling interval in the site/user config files
(Section~\ref{SiteAndUserConfiguration}). For pyro and ssh task communications
polling is not done by default but it can still be configured here as a
regular check on the health of submitted tasks.

Each list value is used in turn until the last, which is used repeatedly 
until finished.

{\em Detaching tasks cannot be polled or killed by cylc - 
see Section~\ref{DetachingTasks}.}

\begin{myitemize}
\item {\em type:} list of floats, optionally {\em preceded} by multipliers
\item {\em example:} \lstinline=1,3*10,1= is equivalent 
        to \lstinline=1,10,10,10,1=
\item {\em root default:} (none)
\end{myitemize}

\paragraph[manual completion]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ manual completion}

If a task's initiating process detaches and exits before task processing
is finished then cylc cannot arrange for the task to automatically
signal when it has succeeded or failed. In such cases you must use this 
configuration item to tell cylc not to arrange for automatic completion
messaging, and insert some minimal completion messaging yourself in
appropriate places in the task implementation (see
Section~\ref{DetachingTasks}).

\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} False
\end{myitemize}

% HIDDEN \paragraph[hours]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ hours}

\paragraph[work directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ work sub-directory}

Task command scripting is executed from with automatically created work
directories, which can be accessed by their tasks through
\lstinline=$CYLC_TASK_WORK_DIR=.  This items sets the low-level
sub-directory name. The default value provides a unique workspace for
each task, but this can overridden to make groups of tasks run in the
same working directory, thereby providing a share space for tasks that 
read and write from their current working directories.

\begin{myitemize}
\item {\em type:} string (directory path, may contain environment variables)
\item {\em default:} \lstinline=$TASK_ID=
\end{myitemize}

\paragraph[enable resurrection]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ enable resurrection}

If a message is received from a failed task cylc will normally treat
this as an error condition, issue a warning, and leave the task in the
``failed'' state.  But if ``enable resurrection'' is switched on failed
tasks can come back from the dead: if the same task job script is
executed again cylc will put the task back into the running state and
continue as normal when the started message is received. This can be
used to handle HPC-style job preemption wherein a resource manager may
kill a running task and reschedule it to run again later, to make way
for a job with higher immediate priority. See also
Section~\ref{PreemptionHPC}, {\em Handling Job Preemption}
\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} False
\end{myitemize}


\paragraph[{[[[}dummy mode{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[dummy mode]]]}

Dummy mode configuration.

\subparagraph[command scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[dummy mode]]] $\rightarrow$ command scripting}

The scripting to execute when the associated task is ready to run, {\em
in dummy mode} - this can be a single command or a multiple lines of
scripting. 

\begin{myitemize}
\item {\em type:} string
\item {\em root default:} \lstinline=echo "Dummy command scripting"; sleep $(cylc rnd 1 16)=
\end{myitemize}

\subparagraph[disable pre-command scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[dummy mode]]] $\rightarrow$ disable pre-command scripting}

This disables pre-command scripting, is likely to contain code specific
to the real task, in dummy mode. 

\begin{myitemize}
\item {\em type:} boolean
\item {\em root default:} True
\end{myitemize}

\subparagraph[disable post-command scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[dummy mode]]] $\rightarrow$ disable post-command scripting}

This disables post-command scripting, which is likely to contain code
specific to the real task, in dummy mode. 

\begin{myitemize}
\item {\em type:} boolean
\item {\em root default:} True
\end{myitemize}

\paragraph[{[[[}simulation mode{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[simulation mode]]]}

Simulation mode configuration.

\paragraph[run time range]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[simulation mode]]] $\rightarrow$ run time range}

This defines an interval \lstinline=[min,max)= (seconds) from within
which the the simulation mode task run length will be randomly chosen.

\begin{myitemize}
\item {\em type:} integer list (two members)
\item {\em root default:} $1,16$
\end{myitemize}

\paragraph[{[[[}job submission{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]]}

This section configures the means by which cylc submits task job scripts to run.

\subparagraph[method]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ method}
\label{RuntimeJobSubMethods}

See {\em Task Job Submission} (Section~\ref{TaskJobSubmission}) 
for how job submission works, and how to define new methods.
Cylc has a number of built in job submission methods:
\begin{myitemize}
\item {\em type:} string
\item {\em legal values:} 
   \begin{myitemize}
       \item {\em background} - direct background execution
       \item {\em at} - the rudimentary Unix \lstinline=at= scheduler
       \item {\em loadleveler} - \lstinline=llsubmit=, with directives defined in the suite.rc file 
       \item {\em pbs} - PBS \lstinline=qsub=, with directives defined in the suite.rc file 
       \item {\em sge} - Sun Grid Engine \lstinline=qsub=, with directives defined in the suite.rc file 
       \item {\em slurm} - Simple Linux Utility for Resource Management \lstinline=sbatch=, with directives defined in the suite.rc file.
   \end{myitemize}
\item {\em default:} \lstinline=background=
\end{myitemize}

\subparagraph[command template]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ command template}

This allows you to override the actual command used by the chosen job
submission method. The template's first \%s will be substituted by the
job file path.  Where applicable the second and third \%s will be
substituted by the paths to the job stdout and stderr files.

\begin{myitemize}
\item {\em type:} string
\item {\em legal values:} a string template
\item {\em example:} \lstinline@llsubmit %s@
\end{myitemize}

\subparagraph[shell]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ shell}
\label{JobSubShell}

This is the shell used to interpret the job script submitted by cylc
when a task is ready to run.  {\em It has no bearing on the shell used
in task implementations.} Command scripting and suite environment 
variable assignment expressions must be valid for this shell. The 
latter is currently hardwired into cylc as 
\lstinline@export item=value@ - valid for both bash and ksh
because \lstinline=value= is entirely user-defined - but cylc would have
to be modified slightly to allow use of the C shell.

\begin{myitemize}
\item {\em type:} string
\item {\em root default:} \lstinline=/bin/bash= 
\end{myitemize}

\subparagraph[retry delays]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ retry delays}
\label{JobSubRefRetries}

A list of time intervals in minutes, after which to resubmit if job
submission fails.
\begin{myitemize}
\item {\em type:} list of floats, optionally {\em preceded} by multipliers
\item {\em example:} \lstinline=1.5,3*10= is equivalent to \lstinline=1.5,10,10,10=
\item {\em root default:} (none)
\end{myitemize}


\paragraph[{[[[}remote{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]]}

Configure host and username, for tasks that do not run on the suite host
account. Passwordless ssh is used to submit the task by the configured
job submission method, so you must distribute your ssh key to allow
this. Cylc must be installed on remote task hosts, but of the external
software dependencies only Pyro is required there (not even that if {\em
ssh messaging} is used; see below).

\subparagraph[host]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ host}
\label{DynamicHostSelection}

The remote host for this namespace. This can be a static hostname, an
environment variable that holds a hostname, or a command that prints a
hostname to stdout. Host selection commands are executed just prior to
job submission. The host (static or dynamic) may have an entry in the
cylc site or user config file to specify parameters such as the location
of cylc on the remote machine; if not, the corresponding local settings
(on the suite host) will be assumed to apply on the remote host. 

\begin{myitemize}
\item {\em type:} string (a valid hostname on the network)
\item {\em default:} (none)
\item {\em examples:}
    \begin{myitemize}
        \item static host name: \lstinline@host = foo@
        \item fully qualified: \lstinline@host = foo.bar.baz@
        \item dynamic host selection:
        \begin{myitemize}
            \item shell command (1): \lstinline@host = $(host-selector.sh)@ 
            \item shell command (2): \lstinline@host = `host-selector.sh)`@
            \item environment variable: \lstinline@host = $MY_HOST@ 
        \end{myitemize}
    \end{myitemize}
\end{myitemize}


\subparagraph[owner]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ owner}

The username of the task host account. This is (only) used in the
passwordless ssh command invoked by cylc to submit the remote task
(consequently it may be defined using local environment variables 
(i.e.\ the shell in which cylc runs, and [cylc] $\rightarrow$ [[environment]]). 

If you use dynamic host selection and have different usernames on
the different selectable hosts, you can configure your
\lstinline=$HOME/.ssh/config= to handle username translation.

\begin{myitemize}
\item {\em type:} string (a valid username on the remote host)
\item {\em default:} (none)
\end{myitemize}

\subparagraph[suite definition directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$  suite definition directory}

The path to the suite definition directory on the remote host, needed if
remote tasks require access to files stored there (via
\lstinline=$CYLC_SUITE_DEF_PATH=) or in the suite bin directory (via
\lstinline=$PATH=).  If this item is not defined, the local suite
definition directory path will be assumed, with the suite owner's home
directory, if present, replaced by \lstinline='$HOME'= for
interpretation on the remote host. 

\begin{myitemize}
\item {\em type:} string (a valid directory path on the remote host)
\item {\em default:} (local suite definition path with \lstinline=$HOME=
    replaced)
\end{myitemize}
 

\paragraph[{[[[}event hooks{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]]}
\label{TaskEventHandling}

Cylc has internal ``hooks'' to which you can attach handlers that are 
called {\em by cylc} whenever certain events occur. This section
configures task event hooks; see Section~\ref{SuiteEventHandling} for
suite event hooks.

Event handlers can send an email or an SMS, call a pager, intervene
in the operation of their own suite, or whatever.
They can be held in the suite bin directory, otherwise it is up to you
to ensure their location is in \lstinline=$PATH= (in the shell in which
cylc runs, on the suite host).
\lstinline=cylc [hook] email-task= is a simple task event handler. 

Task event handlers are called by cylc with the following arguments:
\begin{lstlisting}
<task-event-handler> EVENT SUITE TASK MESSAGE
\end{lstlisting}
where,
\begin{myitemize}
    \item EVENT - event name (see below)
    \item SUITE - suite name
    \item TASK  - task ID
    \item MESSAGE - describes what has happened.
\end{myitemize}

Additional information can be passed to event handlers via the
[cylc] $\rightarrow$ [[environment]] (but not via task
runtime environments - event handlers are not called by tasks).

\subparagraph[EVENT handler]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ EVENT handler}

Specify a handler script to call when one of the following EVENTs occurs:
\begin{myitemize}
    \item {\bf submitted}      - the job submit command was successful
    \item {\bf submission failed}  - the job submit command failed, or the
                                   submitted job was killed before it started executing
    \item {\bf submission retry}   - job submit failed, but cylc will resubmit it
                                   after a configured delay
    \item {\bf submission timeout} - the submitted job timed out without commencing execution 

    \item {\bf started}        - the task reported commencement of execution
    \item {\bf succeeded}      - the task reported that it completed successfully
    \item {\bf failed}         - the task reported that if tailed to complete successfully
    \item {\bf retry}          - the task failed, but cylc will resubmit it
                                  after a configured delay
    \item {\bf execution timeout}        - the task timed out after execution commenced
    \item {\bf warning}        - the task reported a warning priority message
\end{myitemize}

Item details:
\begin{myitemize}
    \item {\em type:} string (event handler script name)
    \item {\em default:} None
    \item {\em example:} \lstinline@failed handler = my-failed-handler.sh@
\end{myitemize}

\subparagraph[submission timeout]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ submission timeout}

If a task has not started the specified number of minutes after it was
submitted, the {\em submission timeout} event handler will be called.
\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[execution timeout]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ execution timeout}

If a task has not finished the specified number of minutes after it
started running, the {\em execution timeout} event handler will be
called.
\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[reset timer]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ reset timer}

If you set an execution timeout the timer can be reset to zero every
time a message is received from the running task (which indicates the 
task is still alive).  Otherwise, the task will timeout if it does not
finish in the alotted time regardless of incoming messages.

\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} False
\end{myitemize}

\paragraph[{[[[}environment{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment]]]}

The user defined task execution environment. Variables defined here can
refer to cylc suite and task identity variables, which are exported
earlier in the task job script, and variable assignment expressions can
use cylc utility commands because access to cylc is also configured
earlier in the script.  See also {\em Task Execution Environment},
Section~\ref{TaskExecutionEnvironment}.

\subparagraph[\_\_VARIABLE\_\_ ]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment]]] $\rightarrow$ \_\_VARIABLE\_\_}
\label{AppendixTaskExecutionEnvironment}

Replace \_\_VARIABLE\_\_ with any number of environment variable
assignment expressions.
Order of definition is preserved so values can refer to previously
defined variables. Values are passed through to the task job script
without evaluation or manipulation by cylc, so any variable assignment
expression that is legal in the job submission shell can be used. 
White space around the `$=$' is allowed (as far as cylc's suite.rc 
parser is concerned these are just normal configuration items).

\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\item {\em legal values:} depends to some extent on the task job
    submission shell (Section~\ref{JobSubShell}). 
\item {\em examples}, for the bash shell: 
   \begin{myitemize}
       \item \lstinline@FOO = $HOME/bar/baz@
       \item \lstinline@BAR = ${FOO}$GLOBALVAR@
       \item \lstinline@BAZ = $( echo "hello world" )@
       \item \lstinline@WAZ = ${FOO%.jpg}.png@
       \item \lstinline@NEXT_CYCLE = $( cylc cycletime -a 6 )@
       \item \lstinline@PREV_CYCLE = `cylc cycletime -s 6`@
       \item \lstinline@ZAZ = "${FOO#bar}" # <-- QUOTED to escape the suite.rc comment character@ 
   \end{myitemize}
\end{myitemize}

\paragraph[{[[[}environment filter{]]]}]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment filter]]]}
\label{EnvironmentFilter}

This section contains environment variable inclusion and exclusion
lists that can be used to filter the inherited environment. {\em This is
not intended as an alternative to a well-designed inheritance hierarchy
that provides each task with just the variables it needs.} Filters can,
however, improve suites with tasks that inherit a lot of environment
they don't need, by making it clear which tasks use which variables.
They can optionally be used routinely as explicit ``task environment
interfaces'' too, at some cost to brevity, because they guarantee that
variables filtered out of the inherited task environment are not used.

Note that environment filtering is done after inheritance is completely
worked out, not at each level on the way, so filter lists in higher-level
namespaces only have an effect if they are not overridden by descendants.

\subparagraph[include]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment filter]]] $\rightarrow$ include}

If given, only variables named in this list will be included from the
inherited environment, others will be filtered out. Variables may also
be explicitly excluded by an \lstinline=exclude= list.

\begin{myitemize}
\item {\em type:} string list
\item {\em default:} (none)
\end{myitemize}

\subparagraph[exclude]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment filter]]] $\rightarrow$ exclude}

Variables named in this list will be filtered out of the inherited
environment.  Variables may also be implicitly excluded by
omission from an \lstinline=include= list.

\begin{myitemize}
\item {\em type:} string list
\item {\em default:} (none)
\end{myitemize}

\paragraph[{[[[}directives{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[directives]]]}

Batch queue scheduler directives.  Whether or not these are used depends
on the job submission method. For the built-in loadleveler, pbs, and sge
methods directives are written to the top of the task job script in
the correct format for the method. Specifying directives individually
like this allows use of default directives that can be individually
overridden at lower levels of the runtime namespace hierarchy.

\subparagraph[\_\_DIRECTIVE\_\_ ]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[directives]]] $\rightarrow$ \_\_DIRECTIVE\_\_}

Replace \_\_DIRECTIVE\_\_ with each directive assignment, e.g. 
\lstinline@class = parallel@

\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\end{myitemize}

Example directives for the built-in job submission methods are shown in
Section~\ref{AvailableMethods}.

\paragraph[{[[[}outputs{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[outputs]]]}

This section is only required if other tasks need to trigger off specific
internal outputs of this task (as opposed to triggering off it finishing).
The task implementation must report the specified output messages 
by calling \lstinline=cylc task message= when the
corresponding real outputs have been completed.

\subparagraph[\_\_OUTPUT\_\_ ]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[outputs]]] $\rightarrow$ \_\_OUTPUT\_\_}

Replace \_\_OUTPUT\_\_ with any number of labelled output messages. 
\begin{myitemize}
    \item {\em type:} string (a message containing
        \lstinline=<CYLC_TASK_CYCLE_TIME>= with an optional offset as shown
        below. Note that you cannot use the corresponding shell variable
        \lstinline=$CYLC_TASK_CYCLE_TIME= here. The string substitution
        (replacing this special variable with the actual task cycle time) is
        done inside cylc, not in the task execution environment.
\item {\em default:} (none)
\item{ \em examples:}
 \begin{lstlisting}
 foo = "sea state products ready for <CYLC_TASK_CYCLE_TIME>"
 bar = "nwp restart files ready for <CYLC_TASK_CYCLE_TIME+6>"
 \end{lstlisting}
 where the item name must match the output label associated with
 this task in the suite dependency graph, e.g.:
\lstset{language=suiterc}
\begin{lstlisting}
[scheduling]
    [dependencies]
        graph = TaskA:foo => TaskB
 \end{lstlisting}
\end{myitemize}
\lstset{language=transcript}

\paragraph[{[[[}suite state polling{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[suite state polling]]]}

Configure automatic suite polling tasks as described in Section~\ref{SuiteStatePolling}. The 
items in this section reflect the options and defaults of the
\lstinline=cylc suite-state= command, except that the target suite name and the 
\lstinline=--task=, \lstinline=--cycle=, and \lstinline=--status= options are 
taken from the graph notation.

\subparagraph[run-dir]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[suite state polling]]] $\rightarrow$ run-dir}

For your own suites the run database location is determined by your
site/user config. For other suites, e.g. those owned by others, or
mirrored suite databases, use this item to specify the location 
of the top level cylc run directory (the database should be a 
suite-name sub-directory of this location). 

\begin{myitemize}
    \item {\em type:} string (a directory path on the target suite host)
    \item {\em default:} as configured by site/user config (for your own suites)
\end{myitemize}

\subparagraph[interval]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[suite state polling]]] $\rightarrow$ interval}

Polling interval.
\begin{myitemize}
    \item {\em type:} integer (seconds)
    \item {\em default:} 60 seconds
\end{myitemize}

\subparagraph[max-polls]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[suite state polling]]] $\rightarrow$ max-polls}

The maximum number of polls before timing out and entering the `failed' state.

\begin{myitemize}
    \item {\em type:} integer (seconds)
    \item {\em default:} 10
\end{myitemize}

\subparagraph[user]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[suite state polling]]] $\rightarrow$ user}

Username of an account on the suite host to which you have access. The
polling \lstinline=cylc suite-state= command will be invoked 
on the remote account.

\begin{myitemize}
    \item {\em type:} string (username)
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[host]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[suite state polling]]] $\rightarrow$ host}

The hostname of the target suite. The polling \lstinline=cylc suite-state= command
will be invoked on the remote account.

\begin{myitemize}
    \item {\em type:} string (hostname)
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[verbose]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[suite state polling]]] $\rightarrow$ verbose}

Run the polling \lstinline=cylc suite-state= command in verbose output mode.

\begin{myitemize}
    \item {\em type:} boolean (seconds)
    \item {\em default:} False
\end{myitemize}

\subsection{[visualization]}

Configuration of suite graphing and, where applicable, the gcylc graph view.
Graphviz documentation of node shapes and so on can be found at 
http://www.graphviz.org/Documentation.php.

\subsubsection[initial cycle time]{[visualization] $\rightarrow$ initial cycle time}

The cycle time from which to start the suite graph.
\begin{myitemize}
    \item {\em type:} integer (YYYY[MM[DD[HH[mm[ss]]]]])
    \item {\em default:} the suite initial cycle time or 2999010100
\end{myitemize}

\subsubsection[final cycle time]{[visualization] $\rightarrow$ final cycle time}

The cycle time at which to end the suite graph.
\begin{myitemize}
    \item {\em type:} integer (YYYY[MM[DD[HH[mm[ss]]]]])
    \item {\em default:} the visualization initial cycle time plus the default runahead limit
\end{myitemize}

\subsubsection[collapsed families]{[visualization] $\rightarrow$ collapsed families}

A list of family (namespace) names to be shown in the collapsed state
(i.e.\ the family members will be replaced by a single family node) when
the suite is first plotted in the graph viewer or the gcylc graph view.
If this item is not set, the default is to collapse all families at first.
Interactive GUI controls can then be used to group and ungroup family
nodes at will.

\begin{myitemize}
    \item {\em type:} list of family names
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[use node color for edges]{[visualization] $\rightarrow$ use node color for edges}

Graph edges (dependency arrows) can be plotted in the same color
as the upstream node (task or family) to make paths through a complex
graph easier to follow.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} True
\end{myitemize}

\subsubsection[use node color for labels]{[visualization] $\rightarrow$ use node color for labels}

Graph node labels can be printed in the same color as the node outline.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}


\subsubsection[default node attributes]{[visualization] $\rightarrow$ default node attributes}

Set the default attributes (color and style etc.) of graph nodes (tasks and families).
Attribute pairs must be quoted to hide the internal \lstinline@=@ character.

\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} \lstinline@'style=filled', 'fillcolor=yellow', 'shape=box'@
\end{myitemize}

\subsubsection[default edge attributes]{[visualization] $\rightarrow$ default edge attributes}

Set the default attributes (color and style etc.) of graph edges
(dependency arrows).  Attribute pairs must be quoted to hide the
internal \lstinline@=@ character.
\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} \lstinline@'color=black'@
\end{myitemize}

\subsubsection[enable live graph movie]{[visualization] $\rightarrow$ enable live graph movie}

If True, the gcylc graph-view write out a dot-language graph file on
every change; these can be post-processed into a movie
showing how the suite evolves. The frames will be written to the run
time graph directory (see below).

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} \lstinline@False@
\end{myitemize}

\subsubsection[{[[}node groups{]]}]{[visualization] $\rightarrow$ [[node groups]]}

Define named groups of graph nodes (tasks and families) which can styled
en masse, by name, in [visualization] $\rightarrow$ [[node attributes]].
Node groups are automatically defined for all task families, including
root, so you can style family and member nodes at once by family name.

\paragraph[\_\_GROUP\_\_]{[visualization] $\rightarrow$ [[node groups]] $\rightarrow$ \_\_GROUP\_\_}

Replace \_\_GROUP\_\_ with each named group of tasks or families.

\begin{myitemize}
    \item {\em type:} comma separated list of task or family names
    \item {\em default:} (none)
    \item {\em example:}
\begin{lstlisting}
   PreProc = foo, bar
   PostProc = baz, waz
\end{lstlisting}
\end{myitemize}

\subsubsection[{[[}node attributes{]]}]{[visualization] $\rightarrow$ [[node attributes]]}

Here you can assign graph node attributes to specific nodes, or to all
members of named groups defined in [visualization] $\rightarrow$ [[node
groups]]. Task families are automatically node groups. Styling of a
family node applies to all member nodes (tasks and sub-families), but
precedence is determined by ordering in the suite definition.  For
example, if you style a family red and then one of its members green,
cylc will plot a red family with one green member; but if you style one
member green and then the family red, the red family styling will
override the earlier green styling of the member.

\paragraph[\_\_NAME\_\_]{[visualization] $\rightarrow$ [[node attributes]] $\rightarrow$ \_\_NAME\_\_}

Replace \_\_NAME\_\_ with each node or node group for style attribute
assignment.

\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} (none)
    \item {\em example:} (with reference to the node groups defined above)
\begin{lstlisting}
   PreProc = 'style=filled', 'fillcolor=orange'
   PostProc = 'color=red'
   foo = 'style=filled'
\end{lstlisting}
\end{myitemize}

\subsubsection[{[[}runtime graph{]]}]{[visualization] $\rightarrow$ [[runtime graph]]}

Cylc can generate graphs of dependencies resolved at run time, i.e.\ what 
actually triggers off what as the suite runs. This feature is retained
mainly for development and debugging purposes. You can use simulation
mode or dummy mode to generate runtime graphs very quickly.

\paragraph[enable]{[visualization] $\rightarrow$ [[runtime graph]] $\rightarrow$ enable}

Runtime graphing is disabled by default.
\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[cutoff]{[visualization] $\rightarrow$ [[runtime graph]] $\rightarrow$ cutoff}

New nodes will be added to the runtime graph as the corresponding tasks
trigger, until their cycle time exceeds the initial cycle time by more
than this cutoff, in hours.

\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, hours)
    \item {\em default:} $24$
\end{myitemize}

\paragraph[directory]{[visualization] $\rightarrow$ [[runtime graph]] $\rightarrow$ directory}

Where to put the runtime graph file, \lstinline=runtime-graph.dot=.

\begin{myitemize}
    \item {\em type:} string (a valid directory path, may contain environment variables)
    \item {\em default:} \lstinline=$CYLC_SUITE_DEF_PATH/graphing=
\end{myitemize}

% HIDDEN \subsection{[development]}

\subsection{Special Placeholder Variables In Suite Definitions}

See Section~\ref{SPHV}.


\subsection{Default Suite Configuration}
\label{SuiteDefaults}

Cylc provides, via \lstinline=$CYLC_DIR/conf/suiterc/*.spec=, sensible
default values for many configuration items so that most users will not
need to explicitly configure log directories and so on. The defaults are
sufficient, in fact, to allow test suites defined by dependency graph
alone (command scripting, for example, defaults to printing a simple
message, sleeping for a few seconds, and then exiting). 

The \lstinline=cylc get-config= command parses a suite definition and
retrieves configuration values for individual items, sections, or entire
suites.

