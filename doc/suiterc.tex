\section{Suite.rc Reference}
\label{SuiteRCReference}

\lstset{language=bash}

This appendix defines all legal suite definition config items.
Embedded Jinja2 code (see~\ref{Jinja2}) must process to a valid
raw suite.rc file. See also~\ref{SuiteRCFile} for a descriptive
overview of suite.rc files, including syntax (\ref{Syntax}).

\subsection{Top Level Items}

The only top level configuration items at present are the suite title
and description.

\subsubsection{title}

A single line description of the suite. It is displayed in the db viewer
window and can be retrieved at run time with the
\lstinline=cylc show= command.

\begin{myitemize}
\item {\em type:} single line string
\item {\em default:} (none)
\end{myitemize}

\subsubsection{description}

A multi-line description of the suite. It can be retrieved by the db viewer
right-click menu, or at run time with the \lstinline=cylc show= command.

\begin{myitemize}
\item {\em type:} multi-line string
\item {\em default:} (none)
\end{myitemize}

\subsection{[cylc]}

This section is for configuration that is not specifically task-related.

\subsubsection[required run mode]{ [cylc] $\rightarrow$ required run mode}

If this item is set cylc will abort if the suite is not started in the
specified mode. This can be used for demo suites that have to be
run in simulation mode, for example, because they have been taken out of
their normal operational context; or to prevent accidental submission of
expensive real tasks during suite development.
\begin{myitemize}
    \item {\em type:} string
    \item {\em legal values:} live, dummy, simulation
    \item {\em default:} None
\end{myitemize}

\subsubsection[UTC mode]{ [cylc] $\rightarrow$ UTC mode}
\label{UTC-mode}

Cylc runs off the suite host's system clock by default. This item allows
you to run the suite in UTC even if the system clock is set to local time.
Clock-triggered tasks will trigger when the current UTC time is equal to
their cycle point date-time plus offset; other time values used, reported,
or logged by the suite daemon will usually also be in UTC.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[cycle point format]{ [cylc] $\rightarrow$ cycle point format}
\label{cycle-point-format}

To just alter the timezone used in the date/time cycle point format, see
\ref{cycle-point-time-zone}. To just alter the number of expanded year digits
(for years below 0 or above 9999), see
\ref{cycle-point-num-expanded-year-digits}.

Cylc usually uses a \lstinline=CCYYMMDDThhmmZ= (\lstinline=Z= in the special
case of UTC) or \lstinline=CCYYMMDDThhmm+hhmm= format (\lstinline=+= standing
for \lstinline=+= or \lstinline=-= here) for writing down date/time cycle
points, which follows one of the basic formats outlined in the ISO 8601
standard. For example, a cycle point on the 3rd of February 2001 at 4:50 in
the morning, UTC (+0000 timezone), would be written
\lstinline=20010203T0450Z=. Similarly, for the the 3rd of February 2001 at
4:50 in the morning, +1300 timezone, cylc would write
\lstinline=20010203T0450+1300=.

You may use the isodatetime library's syntax to write dates and times in ISO
8601 formats - \lstinline=CC= for century, \lstinline=YY= for decade and
decadal year, \lstinline=+X= for expanded year digits and their positive or
negative sign, thereafter following the ISO 8601 standard example notation
except for fractional digits, which are represented as \lstinline=,ii= for
\lstinline=hh=, \lstinline=,nn= for \lstinline=mm=, etc. For example, to write
date/times as week dates with fractional hours, set cycle point format to
\lstinline=CCYYWwwDThh,iiZ= e.g. \lstinline=1987W041T08,5Z= for 08:30 UTC on
Monday on the fourth ISO week of 1987.

You can also use a subset of the strptime/strftime POSIX standard - supported
tokens are \lstinline=\%F=, \lstinline=\%H=, \lstinline=\%M=, \lstinline=\%S=,
\lstinline=\%Y=, \lstinline=\%d=, \lstinline=\%j=, \lstinline=\%m=,
\lstinline=\%s=, \lstinline=\%z=.

To use the old cylc date-time format (e.g. \lstinline=2014020106= for 06:00
on the 1st of February 2014), set cycle point format to
\lstinline=\%Y\%m\%d\%H=.

Please note that using characters like "/" is not allowed, as it will break
task output files ("/" is a reserved character in POSIX file and directory
naming). Using ":" is also not allowed, as it is likely to interfere with
usage of commands like "rsync" when applied to task output files.

\subsubsection[cycle point num expanded year digits]{ [cylc] $\rightarrow$
cycle point num expanded year digits}
\label{cycle-point-num-expanded-year-digits}

For years below 0 or above 9999, the ISO 8601 standard specifies that an
extra number of year digits and a sign should be used. This extra number needs
to be written down somewhere (here).

For example, if this extra number is set to 2, 00Z on the 1st of January in
the year 10040 will be represented as \lstinline=+0100400101T0000Z= (2 extra
year digits used). With this number set to 3, 06Z on the 4th of May 1985 would
be written as \lstinline=+00019850504T0600Z=.

This number defaults to 0 (no sign or extra digits used).

\subsubsection[cycle point time zone]{ [cylc] $\rightarrow$
cycle point time zone}
\label{cycle-point-time-zone}

If you set UTC mode to True (\ref{UTC-mode}) then this will default to
\lstinline=Z=. If you use a custom cycle point format
(\ref{cycle-point-format}), you should specify the timezone choice (or null
timezone choice) here as well.

You may set your own time zone choice here, which will be used for all
date/time cycle point dumping. Time zones should be expressed as ISO 8601 time
zone offsets from UTC, such as \lstinline=+13=, \lstinline=+1300=,
\lstinline=-0500= or \lstinline=+0645=, with \lstinline=Z= representing the
special \lstinline=+0000= case. Cycle points will be converted to the time
zone you give and will be represented with this string at the end.

Cycle points that are input without time zones (e.g. as an initial cycle point
setting) will use this time zone if set. If this isn't set (and UTC mode is
also not set), then they will default to the current local time zone.

Note that the ISO standard also allows writing the hour and minute separated
by a ":" (e.g. \lstinline=+13:00=) - however, this is not recommended, given
that the time zone is used as part of task output filenames.

\subsubsection[abort if any task fails]{[cylc] $\rightarrow$ abort if any task fails}

Cylc does not normally abort if tasks fail, but if this item is turned
on it will abort with exit status 1 if any task fails.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[log resolved dependencies]{[cylc] $\rightarrow$ log resolved dependencies}

If this is turned on cylc will write the resolved dependencies of each
task to the suite log as it becomes ready to run (a list of the IDs of
the tasks that actually satisfied its prerequisites at run time). Mainly
used for cylc testing and development.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[{[[}event hooks{]]}]{[cylc] $\rightarrow$ [[event hooks]]}
\label{SuiteEventHandling}

Cylc has internal ``hooks'' to which you can attach handlers that are
called by the suite daemon whenever certain events occur. This section
configures suite event hooks; see~\ref{TaskEventHandling} for
task event hooks.

Event handlers can send an email or an SMS, call a pager, intervene in
the operation of their own suite, or whatever.
They can be held in the suite bin directory, otherwise it is up to you
to ensure their location is in \lstinline=$PATH= (in the shell in which
cylc runs, on the suite host).
\lstinline=cylc [hook] email-suite= is a simple suite event handler.

Suite event handlers are called by the suite daemon with the following arguments:
\begin{lstlisting}
<suite-event-handler> EVENT SUITE MESSAGE
\end{lstlisting}
where,
\begin{myitemize}
    \item EVENT - event name (see below)
    \item SUITE - suite name
    \item MESSAGE - describes what has happened.
\end{myitemize}

Additional information can be passed to event handlers via
[cylc] $\rightarrow$ [[environment]].

\paragraph[EVENT handler]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ EVENT handler}

A list of one or more event handlers to call when one of the following EVENTs occurs:
\begin{myitemize}
    \item {\bf startup}  - the suite has started running
    \item {\bf shutdown} - the suite is shutting down
    \item {\bf timeout}  - the suite has timed out
\end{myitemize}

Item details:
\begin{myitemize}
    \item {\em type:} string (event handler script name)
    \item {\em default:} None
    \item {\em example:} \lstinline@startup handler = my-handler.sh@
\end{myitemize}

\paragraph[timeout]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ timeout}

If a timeout is set and the timeout event is handled, the timeout event
handler(s) will be called if the suite times out before it finishes.
The timer is set initially at suite start up.

\begin{myitemize}
    \item {\em type:} ISO 8601 duration/interval representation (e.g.
 \lstinline=PT5S=, 5 seconds, \lstinline=PT1S=, 1 second) - minimum 0 seconds.
    \item {\em default:} (none)
\end{myitemize}

\paragraph[reset timer]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ reset timer}

If \lstinline=True= (the default) the suite timer will continually reset
after any task changes state, so you can time out after some interval
since the last activity occured rather than on absolute suite execution
time.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} True
\end{myitemize}

\paragraph[abort on timeout]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ abort on timeout}

If a suite timer is set (above) this will cause the suite to abort with
error status if the suite times out while still running.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[abort if startup handler fails]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ abort if EVENT handler fails}

Cylc does not normally care whether an event handler succeeds or fails,
but if this is turned on the EVENT handler will be executed in the
foreground (which will block the suite while it is running) and the
suite will abort if the handler fails.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[{[[}environment{]]} ]{[cylc] $\rightarrow$ [[environment]]}

Environment variables defined in this section are passed to suite and
task event handlers.

\begin{myitemize}
    \item These variables are not passed to tasks - use task runtime
        variables for that. Similarly, task runtime variables are not
        available to event handlers - which are executed by the suite daemon,
        (not by running tasks) in response to task events.
        
    \item Cylc-defined environment variables such as
        \lstinline=$CYLC_SUITE_RUN_DIR= are not passed to task event
        handlers by default, but you can make them available by
        extracting them to the cylc environment like this:
\begin{lstlisting}
[cylc]
    [[environment]]
        CYLC_SUITE_RUN_DIR = $CYLC_SUITE_RUN_DIR
\end{lstlisting}

    \item These variables - unlike task execution environment variables
        which are written to job scripts and interpreted by the shell at
        task run time - are not interpreted by the shell prior to use
        so shell variable expansion expressions cannot be used here.
\end{myitemize}

\paragraph[\_\_VARIABLE\_\_ ]{[cylc] $\rightarrow$ [[environment]] $\rightarrow$ \_\_VARIABLE\_\_}

Replace \_\_VARIABLE\_\_ with any number of environment variable
assignment expressions.
Values may refer to other local environment variables (order of
definition is preserved) and are not evaluated or manipulated by
cylc, so any variable assignment expression that is legal in the
shell in which cylc is running can be used (but see the warning
above on variable expansions, which will not be evaluated).
White space around the `$=$' is allowed (as far as cylc's file 
parser is concerned these are just suite configuration items).

\begin{myitemize}
    \item {\em type:} string
    \item {\em default:} (none)
    \item {\em examples:}
        \begin{myitemize}
            \item \lstinline@FOO = $HOME/foo@
        \end{myitemize}
\end{myitemize}


\subsubsection[{[[}reference test{]]}]{[cylc] $\rightarrow$ [[reference test]] }
\label{ReferenceTestConfig}

Reference tests are finite-duration suite runs that abort with non-zero
exit status if cylc fails, if any task fails, if the suite times
out, or if a shutdown event handler that (by default) compares the test
run with a reference run reports failure. See~\ref{AutoRefTests}.

\paragraph[suite shutdown event handler]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ suite shutdown event handler}

A shutdown event handler that should compare the test run with the
reference run, exiting with zero exit status only if the test run
verifies.

\begin{myitemize}
    \item {\em type:} string (event handler command name or path)
    \item {\em default:} \lstinline=cylc hook check-triggering=
\end{myitemize}
As for any event handler, the full path can be ommited if the script is
located somewhere in \lstinline=$PATH= or in the suite bin directory.

\paragraph[required run mode]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ required run mode}

If your reference test is only valid for a particular run mode, this
setting will cause cylc to abort if a reference test is attempted
in another run mode.

\begin{myitemize}
    \item {\em type:} string
    \item {\em legal values:} live, dummy, simulation
    \item {\em default:} None
\end{myitemize}

\paragraph[allow task failures]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ allow task failures}

A reference test run will abort immediately if any task fails, unless
this item is set, or a list of {\em expected task failures} is provided
(below).

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[expected task failures]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ expected task failures}

A reference test run will abort immediately if any task fails, unless
{\em allow task failures} is set (above) or the failed task is found
in a list IDs of tasks that are expected to fail.

\begin{myitemize}
    \item {\em type:} string list (task IDs: \lstinline=name.cycle_point=)
    \item {\em default:} (none)
    \item {\em example:} \lstinline=foo.20120808, bar.20120908=
\end{myitemize}

\paragraph[live mode suite timeout]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ live mode suite timeout}

The timeout value, expressed as an ISO 8601 duration/interval, after which the
test run should be aborted if it has not finished, in live mode. Test runs
cannot be done in live mode unless you define a value for this item, because
it is not possible to arrive at a sensible default for all suites.

\begin{myitemize}
    \item {\em type:} ISO 8601 duration/interval representation (e.g.
 \lstinline=PT5M=, 5 minutes (note: by contrast, \lstinline=P5M= means 5
 months, so remember the \lstinline=T=!)).
    \item {\em default:} PT1M (1 minute)
\end{myitemize}

\paragraph[simulation mode suite timeout]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ simulation mode suite timeout}

The timeout value in minutes after which the test run should be aborted
if it has not finished, in simulation mode. Test runs cannot be done in
simulation mode unless you define a value for this item, because it is
not possible to arrive at a sensible default for all suites.

\begin{myitemize}
    \item {\em type:} ISO 8601 duration/interval representation (e.g.
 \lstinline=PT5M=, 5 minutes (note: by contrast, \lstinline=P5M= means 5
 months, so remember the \lstinline=T=!)).
    \item {\em default:} PT1M (1 minute)
\end{myitemize}

\paragraph[dummy mode suite timeout]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ dummy mode suite timeout}

The timeout value, expressed as an ISO 8601 duration/interval, after which the
test run should be aborted if it has not finished, in dummy mode.  Test runs
cannot be done in dummy mode unless you define a value for this item, because
it is not possible to arrive at a sensible default for all suites.

\begin{myitemize}
    \item {\em type:} ISO 8601 duration/interval representation (e.g.
 \lstinline=PT5M=, 5 minutes (note: by contrast, \lstinline=P5M= means 5
 months, so remember the \lstinline=T=!)).
    \item {\em default:} PT1M (1 minute)
\end{myitemize}

\subsection{[scheduling]}

This section allows cylc to determine when tasks are ready to run.

\subsubsection[cycling]{ [scheduling] $\rightarrow$ cycling mode }
\label{cycling-mode}

Cylc runs using the proleptic Gregorian calendar by default. This item allows
you to either run the suite using the 360 day calendar (12 months of 30 days 
in a year) or using integer cycling.

\begin{myitemize}
    \item {\em type:} string
    \item {\em legal values:} gregorian, 360day, integer
    \item {\em default:} gregorian
    
\end{myitemize}

\subsubsection[initial cycle point]{[scheduling] $\rightarrow$ initial cycle point}
\label{initial cycle point}

In a cold start each cycling task (unless specifically excluded under
[special tasks]) will be loaded into the suite with this cycle point,
or with the closest subsequent valid cycle point for the task. Note that
special {\em cold-start tasks} are not loaded in a warm start. If this item is
provided you can override it on the command line or in the gcylc suite start
panel.

In date-time cycling, if you do not provide time zone information for this,
it will be assumed to be local time, or in UTC if~\ref{UTC-mode} is set, or in
the time zone determined by \ref{cycle-point-time-zone} if that is set.

\begin{myitemize}
    \item {\em type:} ISO 8601 date/time point representation (e.g.
 \lstinline=CCYYMMDDThhmm=, 19951231T0630)
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[final cycle point]{[scheduling] $\rightarrow$ final cycle point}

Cycling tasks are held once they pass the final cycle point, if one is
specified. Once all tasks have achieved this state the suite will shut
down. If this item is provided you can override it on the command line
or in the gcylc suite start panel.

In date-time cycling, if you do not provide time zone information for this,
it will be assumed to be local time, or in UTC if \ref{UTC-mode} is set, or in
the \ref{cycle-point-time-zone} if that is set.

\begin{myitemize}
    \item {\em type:} ISO 8601 date/time point representation (e.g.
 \lstinline=CCYYMMDDThhmm=, 19951231T1230) or ISO 8601 date/time offset
    (e.g. +P1D+PT6H)
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[initial cycle point]{[scheduling] $\rightarrow$ initial cycle point constraints}
\label{initial cycle point constraints}

In a cycling suite it is possible to restrict the initial cycle point by
defining a list of truncated time points under the initial cycle point 
constraints.

\begin{myitemize}
    \item {\em type:} List of ISO 8601 truncated time point representations 
    (e.g. T00, T06, T-30)
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[final cycle point]{[scheduling] $\rightarrow$ final cycle point constraints}
\label{final cycle point constraints}

In a cycling suite it is possible to restrict the final cycle point by
defining a list of truncated time points under the final cycle point 
constraints.

\begin{myitemize}
    \item {\em type:} List of ISO 8601 truncated time point representations 
    (e.g. T00, T06, T-30)
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[runahead limit]{[scheduling] $\rightarrow$ runahead limit}
\label{runahead limit}

Runahead limiting prevents the fastest tasks in a suite from getting too far
ahead of the slowest ones, as documented in~\ref{RunaheadLimit}.

This config item specifies a hard limit as a cycle interval between the
slowest and fastest tasks. It is deprecated in favour of the newer default 
limiting by \lstinline=max active cycle points= (\ref{max active cycle points}).

\begin{myitemize}
    \item {\em type:} Cycle interval string e.g. \lstinline=PT12H=
    for a 12 hour limit under ISO 8601 cycling.
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[max active cycle points]{[scheduling] $\rightarrow$
 max active cycle points}
\label{max active cycle points}

Runahead limiting prevents the fastest tasks in a suite from getting too far
ahead of the slowest ones, as documented in~\ref{RunaheadLimit}.

This config item supersedes the deprecated hard \lstinline=runahead limit= 
(\ref{runahead limit}). It allows up to \lstinline=N= (default 3) consecutive
cycle points to be active at any time, adjusted up if necessary for
any future triggering.

\begin{myitemize}
    \item {\em type:} integer
    \item {\em default:} 3
\end{myitemize}


\subsubsection[{[[}queues{]]}]{[scheduling] $\rightarrow$ [[queues]]}

Configuration of internal queues, by which the number of simultaneously
active tasks (submitted or running) can be limited, per queue. By
default a single queue called {\em default} is defined, with all tasks
assigned to it and no limit. To use a single queue for the whole suite
just set the limit on the {\em default} queue as required.
See also~\ref{InternalQueues}.

\paragraph[{[[[}\_\_QUEUE\_\_{]]]}]{[scheduling] $\rightarrow$ [[queues]] $\rightarrow$ [[[\_\_QUEUE\_\_]]]}

Section heading for configuration of a single queue. Replace
\_\_QUEUE\_\_ with a queue name, and repeat the section as required.

\begin{myitemize}
\item {\em type:} string
\item {\em default:} ``default''
\end{myitemize}

\paragraph[limit]{[scheduling] $\rightarrow$ [[queues]] $\rightarrow$ [[[\_\_QUEUE\_\_]]] $\rightarrow$ limit}

The maximum number of active tasks allowed at any one time, for this queue.
\begin{myitemize}
\item {\em type:} integer
\item {\em default:} 0 (i.e.\ no limit)
\end{myitemize}

\paragraph[members]{[scheduling] $\rightarrow$ [[queues]] $\rightarrow$ [[[\_\_QUEUE\_\_]]] $\rightarrow$ members}

A list of member tasks, or task family names, to assign to this queue
(assigned tasks will automatically be removed from the default queue).
\begin{myitemize}
\item {\em type:} string list
\item {\em default:} none for user-defined queues; all tasks for the ``default'' queue
\end{myitemize}

\subsubsection[{[[}special tasks{]]}]{[scheduling] $\rightarrow$ [[special tasks]]}

This section is used to identify any tasks with several kinds of special
behaviour. Family names can be used in special task lists as shorthand
for listing all member tasks.

\paragraph[clock-triggered]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ clock-triggered}

Clock-triggered tasks wait on a wall clock time specified as an offset from
their own cycle point, in addition to dependence on other tasks.
Clock-triggers can be used to make tasks that wait on external real time
data trigger at the expected time of data availability, or to make suite
polling tasks trigger at the expected time of the remote suite event.
In delayed or historical operation clock-triggered tasks do not constrain the
suite until they catch up to the wall clock.

\begin{myitemize}
    \item {\em type:} list of task or family names with offsets expressed as an
        ISO8601 interval string, positive or negative, e.g. \lstinline=PT1H=
        for 1 hour.
    \item {\em default:} (none)
    \item {\em examples:} \lstinline=foo(PT1H30M)=, \lstinline=bar(PT1.5H)=
\end{myitemize}

\paragraph[sequential]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ sequential}

Sequential tasks are automatically given dependence on their own
predecessor. This is equivalent to use of explicit inter-cycle triggers
in the graph, except that the automatic version does not show in suite
graph visualization. For more on sequential tasks see~\ref{SequentialTasks}
and~\ref{LimitPID}.

\begin{myitemize}
    \item {\em type:} list of task or family names
    \item {\em default:} (none)
    \item {\em example:} \lstinline@sequential = foo, bar@
\end{myitemize}

\paragraph[cold-start]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ cold-start}

A cold-start task is one-off task used to satisfy the dependence of an
associated task with the same cycle point, on outputs from a previous
cycle - when those outputs are not available.  The primary use for this
is to cold-start a warm-cycled forecast model that normally depends on
restart files (e.g.\ model background fields) generated by its previous
forecast, when there is no previous forecast.  This is required when
cold-starting the suite, but cold-start tasks can also be inserted into
a running suite to restart a model that has had to skip some cycles
after running into problems. Cold-start tasks can invoke real cold-start
processes, or they can just be dummy tasks that represent some external
process that has to be completed before the suite is started. Unlike
{\em start-up} tasks, dependence on cold-start tasks is preseverved in
subsequent cycles so they must typically be used in OR'd conditional
expressions to avoid holding up the suite.

\begin{myitemize}
    \item {\em type:} list of task or family names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[one-off]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ one-off}

Synchronous one-off tasks have an associated cycle point but do not spawn
a successor. Synchronous {\em start-up} and {\em cold-start} tasks are
automatically one-off tasks and do not need to be listed here.
Dependence on one-off tasks is not restricted to the first cycle.

\begin{myitemize}
\item {\em type:} list of task or family names
\item {\em default:} (none)
\end{myitemize}

\paragraph[exclude at start-up]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ exclude at start-up}
\label{EASU}

Any task listed here will be excluded from the initial task pool (this
goes for suite restarts too). If an {\em inclusion} list is also
specified, the initial pool will contain only included tasks that have
not been excluded. Excluded tasks can still be inserted at run time.
Other tasks may still depend on excluded tasks if they have not been
removed from the suite dependency graph, in which case some manual
triggering, or insertion of excluded tasks, may be required.

\begin{myitemize}
    \item {\em type:} list of task or family names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[include at start-up]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ include at start-up}
\label{IASU}

If this list is not empty, any task {\em not} listed in it will be
excluded from the initial task pool (this goes for suite restarts too).
If an {\em exclusion} list is also specified, the initial pool will
contain only included tasks that have not been excluded. Excluded tasks
can still be inserted at run time. Other tasks may still depend on
excluded tasks if they have not been removed from the suite dependency
graph, in which case some manual triggering, or insertion of excluded
tasks, may be required.

\begin{myitemize}
    \item {\em type:} list of task or family names
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[{[[}dependencies{]]}]{[scheduling] $\rightarrow$ [[dependencies]]}

The suite dependency graph is defined under this section.  You can plot
the dependency graph as you work on it, with \lstinline=cylc graph= or
by right clicking on the suite in the db viewer.  See
also~\ref{ConfiguringScheduling}.

\paragraph[graph]{ [scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ graph }

The dependency graph for a completely non-cycling suites can go here.
See also~\ref{GraphDescrip} below and~\ref{ConfiguringScheduling}, for graph
string syntax.
\begin{myitemize}
    \item {\em type:} string
    \item {\em example:} (see~\ref{GraphDescrip} below)
\end{myitemize}

\paragraph[{[[[}\_\_RECURRENCE\_\_{]]]}]{[scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ [[[\_\_RECURRENCE\_\_]]]}

\_\_RECURRENCE\_\_ section headings define the sequence of cycle points for
which the subsequent graph section is valid. These should be specified in
our ISO 8601 derived sequence syntax, or similar for integer cycling:
\begin{myitemize}
    \item {\em examples:}
        \begin{myitemize}
            \item date-time cycling:
                \lstinline@[[[T00,T06,T12,T18]]]@ or \lstinline@[[[PT6H]]]@
            \item integer cycling (stepped by 2):
                \lstinline@[[[P2]]]@
        \end{myitemize}
    \item {\em default:} (none)
\end{myitemize}

See~\ref{GraphTypes} for more on recurrence expressions, and how multiple graph
sections combine.

\subparagraph[graph]{[scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ [[[\_\_RECURRENCE\_\_]]] $\rightarrow$ graph }
\label{GraphDescrip}

The dependency graph for a given recurrence section goes here. Syntax examples
follow; see also~\ref{ConfiguringScheduling} and~\ref{TriggerTypes}.

\begin{myitemize}
\item {\em type:} string
\item {\em examples:}
  \begin{lstlisting}
graph = """
   foo => bar => baz & waz     # baz and waz both trigger off bar
   foo[-P1D-PT6H] => bar       # bar triggers off foo[-P1D-PT6H]
   baz:out1 => faz             # faz triggers off a message output of baz
   ColdFoo | foo[-PT6H] => foo # cold-start or restart for foo
   X:start => Y                # Y triggers if X starts executing
   X:fail => Y                 # Y triggers if X fails
   foo[-PT6H]:fail => bar      # bar triggers if foo[-PT6H] fails
   X => !Y                     # Y suicides if X succeeds
   X | X:fail => Z             # Z triggers if X succeeds or fails
   X:finish => Z               # Z triggers if X succeeds or fails
   (A | B & C ) | D => foo     # general conditional triggers
   foo:submit => bar           # bar triggers if foo is successfully submitted
   foo:submit-fail => bar      # bar triggers if submission of foo fails
   # comment
   """
  \end{lstlisting}
\item {\em default:} (none)
\end{myitemize}

\subsection{[runtime]}

This section is used to specify how, where, and what to execute when
tasks are ready to run. Common
configuration can be factored out in a multiple-inheritance hierarchy of
runtime namespaces that culminates in the tasks of the suite. Order of
precedence is determined by the C3 linearization algorithm as used to
find the {\em method resolution order} in Python language class
hiearchies. For details and examples see~\ref{NIORP}.

\subsubsection[{[[}\_\_NAME\_\_{]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]]}

Replace \_\_NAME\_\_ with a namespace name, or a comma separated list of
names, and repeat as needed to define all tasks in the suite. Names may
contain letters, digits, underscores, and hyphens. A namespace
represents a group or family of tasks if other namespaces inherit from
it, or a task if no others inherit from it.

%Names may not contain colons (which would preclude use of directory paths
%involving the registration name in \lstinline=$PATH= variables). They
%may not contain the `.' character (it will be interpreted as the
%namespace hierarchy delimiter, separating groups and names -huh?).

\begin{myitemize}
\item {\em legal values:}
    \begin{myitemize}
        \item \lstinline=[[foo]]=
        \item \lstinline=[[foo, bar, baz]]=
    \end{myitemize}
\end{myitemize}

If multiple names are listed the subsequent settings apply to each.

All namespaces inherit initially from {\em root}, which can be
explicitly configured to provide or override default settings
for all tasks in the suite.

\paragraph[inherit]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ inherit}

A list of the immediate parent(s) this namespace inherits from. If no
parents are listed \lstinline=root= is assumed.

\begin{myitemize}
\item {\em type:} string list (parent namespace names)
\item {\em default:} \lstinline=root=
\end{myitemize}

\paragraph[title]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ title}

A single line description of this namespace. It is displayed by the
\lstinline=cylc list= command and can be retrieved from running tasks
with the \lstinline=cylc show= command.

\begin{myitemize}
\item {\em type:} single line string
\item {\em root default:} (none)
\end{myitemize}

\paragraph[description]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ description}

A multi-line description of this namespace, retrievable from running tasks with the
\lstinline=cylc show= command.

\begin{myitemize}
\item {\em type:} multi-line string
\item {\em root default:} (none)
\end{myitemize}


\paragraph[initial scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ initial scripting}

Initial scripting is executed at the top of the task job script just
before the \lstinline=cylc task started= message call is made, and
before the task execution environment is configured - so it does not
have access to any suite or task environment variables.  The original
intention was to allow remote tasks to source login scripts before
calling the first cylc command, e.g.\ to set \lstinline=$PYTHONPATH= if
Pyro has been installed locally. Note however that the remote task
invocation mechanism now automatically sources both
\lstinline=/etc/profile= and \lstinline=$HOME/.profile= if they exist.
For other uses pre-command scripting should be used if possible because
it can has access to the task execution environment.
\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\item {\em example:} \lstinline@initial scripting = "echo Hello World"@
\end{myitemize}

\paragraph[environment scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ environment scripting}

Environment scripting is inserted into the task job script between
the cylc-defined environment (suite and task identity, etc.) and the
user-defined task runtime environment - i.e.\ it has access to the
cylc environment, and the task environment has access to the results of
this scripting.
\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\item {\em example:} \lstinline@environment scripting = "echo Hello World"@
\end{myitemize}

\paragraph[command scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ command scripting}

The scripting to execute when the associated task is ready to run - this
can be a single command or multiple lines of scripting.

\begin{myitemize}
\item {\em type:} string
\item {\em root default:} \lstinline=echo "Default command scripting"; sleep 10=
\end{myitemize}


\paragraph[pre-command scripting]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ pre-command scripting}

Scripting to be executed immediately {\em before} the command scripting.
This would typically be used to add scripting to every task in a family
(for individual tasks you could just incorporate the extra commands into
the main command scripting). See also {\em post-command scripting},
below.

\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\item {\em example:}
 \begin{lstlisting}
    pre-command scripting = """
      . $HOME/.profile
      echo Hello from suite ${CYLC_SUITE_REG_NAME}!"""
 \end{lstlisting}
\end{myitemize}

\paragraph[post-command scripting]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ post-command scripting}

Scripting to be executed immediately {\em after} the command scripting.
This would typically be used to add scripting to every task in a family
(for individual tasks you could just incorporate the extra commands into
the main command scripting). See also {\em pre-command scripting},
above.

\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\end{myitemize}

\paragraph[retry delays]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ retry delays}
\label{RefRetries}

A list of ISO 8601 time duration/intervals after which to resubmit the task
if it fails. The variable \lstinline=$CYLC_TASK_TRY_NUMBER= in the task
execution environment is incremented each time, starting from 1 for the
first try - this can be used to vary task behavior by try number.

\begin{myitemize}
    \item {\em type:} list of ISO 8601 duration/interval representations,
    optionally {\em preceded} by multipliers
    \item {\em example:} \lstinline=PT1.5M,3*PT10M= is equivalent to
    \lstinline=PT1.5M, PT10M, PT10M, PT10M= - 1.5 minutes, 10 minutes,
    10 minutes, 10 minutes.
    \item {\em default:} (none)
\end{myitemize}

\paragraph[submission polling intervals]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ submission polling intervals}
\label{SubmissionPollingIntervals}

A list of intervals, expressed as ISO 8601 duration/intervals, with optional
multipliers, after which cylc will poll for status while the task is in the
submitted state.

For the polling task communications method this overrides the default
submission polling interval in the site/user config files
(\ref{SiteAndUserConfiguration}). For pyro and ssh task communications
polling is not done by default but it can still be configured here as a
regular check on the health of submitted tasks.

Each list value is used in turn until the last, which is used repeatedly
until finished.

{\em Detaching tasks cannot be polled or killed by the suite daemon -
see~\ref{DetachingTasks}.}

\begin{myitemize}
    \item {\em type:} list of ISO 8601 duration/interval representations,
    optionally {\em preceded} by multipliers
    \item {\em example:} \lstinline=PT1M,3*PT1H, PT1M= is equivalent to
    \lstinline=PT1M, PT1H, PT1H, PT1H, PT1M= - 1 minute, 1 hour, 1 hour, 1
    hour, 1 minute.
    \item {\em default:} (none)
\end{myitemize}
A single interval value is probably appropriate for submission polling.

\paragraph[execution polling intervals]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ execution polling intervals}
\label{ExecutionPollingIntervals}

A list of intervals, expressed as ISO 8601 duration/intervals, with optional
multipliers, after which cylc will poll for status while the task is in the
running state.

For the polling task communications method this overrides the default
execution polling interval in the site/user config files
(\ref{SiteAndUserConfiguration}). For pyro and ssh task communications
polling is not done by default but it can still be configured here as a
regular check on the health of submitted tasks.

Each list value is used in turn until the last, which is used repeatedly
until finished.

{\em Detaching tasks cannot be polled or killed by the suite daemon -
see~\ref{DetachingTasks}.}

\begin{myitemize}
    \item {\em type:} list of ISO 8601 duration/interval representations,
    optionally {\em preceded} by multipliers
    \item {\em example:} \lstinline=PT1M,3*PT1H, PT1M= is equivalent to
    \lstinline=PT1M, PT1H, PT1H, PT1H, PT1M= - 1 minute, 1 hour, 1 hour, 1
    hour, 1 minute.
    \item {\em default:} (none)
\end{myitemize}

\paragraph[manual completion]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ manual completion}

If a task's initiating process detaches and exits before task processing
is finished then cylc cannot arrange for the task to automatically
signal when it has succeeded or failed. In such cases you must use this
configuration item to tell cylc not to arrange for automatic completion
messaging, and insert some minimal completion messaging yourself in
appropriate places in the task implementation (see~\ref{DetachingTasks}).

\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} False
\end{myitemize}

% HIDDEN \paragraph[hours]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ hours}

\paragraph[work directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ work sub-directory}

Task command scripting is executed from with automatically created work
directories, which can be accessed by their tasks through
\lstinline=$CYLC_TASK_WORK_DIR=.  This items sets the low-level
sub-directory name. The default value provides a unique workspace for
each task, but this can overridden to make groups of tasks run in the
same working directory, thereby providing a share space for tasks that
read and write from their current working directories.

\begin{myitemize}
\item {\em type:} string (directory path, may contain environment variables)
\item {\em default:} \lstinline=$TASK_ID=
\end{myitemize}

\paragraph[enable resurrection]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ enable resurrection}

If a message is received from a failed task cylc will normally treat
this as an error condition, issue a warning, and leave the task in the
``failed'' state.  But if ``enable resurrection'' is switched on failed
tasks can come back from the dead: if the same task job script is
executed again cylc will put the task back into the running state and
continue as normal when the started message is received. This can be
used to handle HPC-style job preemption wherein a resource manager may
kill a running task and reschedule it to run again later, to make way
for a job with higher immediate priority. See also~\ref{PreemptionHPC}
\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} False
\end{myitemize}


\paragraph[{[[[}dummy mode{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[dummy mode]]]}

Dummy mode configuration.

\subparagraph[command scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[dummy mode]]] $\rightarrow$ command scripting}

The scripting to execute when the associated task is ready to run, {\em
in dummy mode} - this can be a single command or a multiple lines of
scripting.

\begin{myitemize}
\item {\em type:} string
\item {\em root default:} \lstinline=echo "Dummy command scripting"; sleep $(cylc rnd 1 16)=
\end{myitemize}

\subparagraph[disable pre-command scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[dummy mode]]] $\rightarrow$ disable pre-command scripting}

This disables pre-command scripting, is likely to contain code specific
to the real task, in dummy mode.

\begin{myitemize}
\item {\em type:} boolean
\item {\em root default:} True
\end{myitemize}

\subparagraph[disable post-command scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[dummy mode]]] $\rightarrow$ disable post-command scripting}

This disables post-command scripting, which is likely to contain code
specific to the real task, in dummy mode.

\begin{myitemize}
\item {\em type:} boolean
\item {\em root default:} True
\end{myitemize}

\paragraph[{[[[}simulation mode{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[simulation mode]]]}

Simulation mode configuration.

\paragraph[run time range]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[simulation mode]]] $\rightarrow$ run time range}

This defines a minimum and a maximum duration (expressed as ISO 8601
duration/intervals) which define a range from which the simulation mode task
run length will be randomly chosen.

\begin{myitemize}
    \item {\em type:} list containing two ISO 8601 duration/interval
    representations
    \item {\em example:} \lstinline=PT1S,PT20S= - a range of 1 second to 20
    seconds
    \item {\em default:} (1, 16)
\end{myitemize}

\paragraph[{[[[}job submission{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]]}

This section configures the means by which cylc submits task job scripts to run.

\subparagraph[method]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ method}
\label{RuntimeJobSubMethods}

See~\ref{TaskJobSubmission} for how job submission works, and how to define
new methods.  Cylc has a number of built in job submission methods:
\begin{myitemize}
\item {\em type:} string
\item {\em legal values:}
   \begin{myitemize}
       \item {\em background} - direct background execution
       \item {\em at} - the rudimentary Unix \lstinline=at= scheduler
       \item {\em loadleveler} - \lstinline=llsubmit=, with directives defined in the suite.rc file
       \item {\em lsf} - IBM Platform LSF \lstinline=bsub=, with directives defined in the suite.rc file
       \item {\em pbs} - PBS \lstinline=qsub=, with directives defined in the suite.rc file
       \item {\em sge} - Sun Grid Engine \lstinline=qsub=, with directives defined in the suite.rc file
       \item {\em slurm} - Simple Linux Utility for Resource Management \lstinline=sbatch=, with directives defined in the suite.rc file.
   \end{myitemize}
\item {\em default:} \lstinline=background=
\end{myitemize}

\subparagraph[command template]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ command template}

This allows you to override the actual command used by the chosen job
submission method. The template's \%(job)s will be substituted by the
job file path.

\begin{myitemize}
\item {\em type:} string
\item {\em legal values:} a string template
\item {\em example:} \lstinline@llsubmit \%(job)s@
\end{myitemize}

\subparagraph[shell]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ shell}
\label{JobSubShell}

This is the shell used to interpret the job script submitted by the suite
daemon when a task is ready to run.  {\em It has no bearing on the shell used
in task implementations.} Command scripting and suite environment
variable assignment expressions must be valid for this shell. The
latter is currently hardwired into cylc as
\lstinline@export item=value@ - valid for both bash and ksh
because \lstinline=value= is entirely user-defined - but cylc would have
to be modified slightly to allow use of the C shell.

\begin{myitemize}
\item {\em type:} string
\item {\em root default:} \lstinline=/bin/bash=
\end{myitemize}

\subparagraph[retry delays]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ retry delays}
\label{JobSubRefRetries}

A list of duration (in ISO 8601 syntax), after which to resubmit if job
submission fails.
\begin{myitemize}
    \item {\em type:} list of ISO 8601 duration/interval representations,
    optionally {\em preceded} by multipliers
    \item {\em example:} \lstinline=PT1M,3*PT1H, P1D= is equivalent to
    \lstinline=PT1M, PT1H, PT1H, PT1H, P1D= - 1 minute, 1 hour, 1 hour, 1
    hour, 1 day.
    \item {\em default:} (none)
\end{myitemize}


\paragraph[{[[[}remote{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]]}

Configure host and username, for tasks that do not run on the suite host
account. Passwordless ssh is used to submit the task by the configured
job submission method, so you must distribute your ssh key to allow
this. Cylc must be installed on remote task hosts, but of the external
software dependencies only Pyro is required there (not even that if {\em
ssh messaging} is used; see below).

\subparagraph[host]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ host}
\label{DynamicHostSelection}

The remote host for this namespace. This can be a static hostname, an
environment variable that holds a hostname, or a command that prints a
hostname to stdout. Host selection commands are executed just prior to
job submission. The host (static or dynamic) may have an entry in the
cylc site or user config file to specify parameters such as the location
of cylc on the remote machine; if not, the corresponding local settings
(on the suite host) will be assumed to apply on the remote host.

\begin{myitemize}
\item {\em type:} string (a valid hostname on the network)
\item {\em default:} (none)
\item {\em examples:}
    \begin{myitemize}
        \item static host name: \lstinline@host = foo@
        \item fully qualified: \lstinline@host = foo.bar.baz@
        \item dynamic host selection:
        \begin{myitemize}
            \item shell command (1): \lstinline@host = $(host-selector.sh)@
            \item shell command (2): \lstinline@host = `host-selector.sh)`@
            \item environment variable: \lstinline@host = $MY_HOST@
        \end{myitemize}
    \end{myitemize}
\end{myitemize}


\subparagraph[owner]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ owner}

The username of the task host account. This is (only) used in the
passwordless ssh command invoked by the suite daemon to submit the remote task
(consequently it may be defined using local environment variables
(i.e.\ the shell in which cylc runs, and [cylc] $\rightarrow$ [[environment]]).

If you use dynamic host selection and have different usernames on
the different selectable hosts, you can configure your
\lstinline=$HOME/.ssh/config= to handle username translation.

\begin{myitemize}
\item {\em type:} string (a valid username on the remote host)
\item {\em default:} (none)
\end{myitemize}

\subparagraph[suite definition directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$  suite definition directory}

The path to the suite definition directory on the remote host, needed if
remote tasks require access to files stored there (via
\lstinline=$CYLC_SUITE_DEF_PATH=) or in the suite bin directory (via
\lstinline=$PATH=).  If this item is not defined, the local suite
definition directory path will be assumed, with the suite owner's home
directory, if present, replaced by \lstinline='$HOME'= for
interpretation on the remote host.

\begin{myitemize}
\item {\em type:} string (a valid directory path on the remote host)
\item {\em default:} (local suite definition path with \lstinline=$HOME=
    replaced)
\end{myitemize}


\paragraph[{[[[}event hooks{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]]}
\label{TaskEventHandling}

Cylc has internal ``hooks'' to which you can attach handlers that are
called by the suite daemon whenever certain events occur. This section
configures task event hooks; see~\ref{SuiteEventHandling} for
suite event hooks.

Event handlers can send an email or an SMS, call a pager, intervene
in the operation of their own suite, or whatever.
They can be held in the suite bin directory, otherwise it is up to you
to ensure their location is in \lstinline=$PATH= (in the shell in which
cylc runs, on the suite host).
\lstinline=cylc [hook] email-task= is a simple task event handler.

Task event handlers are called by the suite daemon with the following arguments:
\begin{lstlisting}
<task-event-handler> EVENT SUITE TASK MESSAGE
\end{lstlisting}
where,
\begin{myitemize}
    \item EVENT - event name (see below)
    \item SUITE - suite name
    \item TASK  - task ID
    \item MESSAGE - describes what has happened.
\end{myitemize}

Additional information can be passed to event handlers via the
[cylc] $\rightarrow$ [[environment]] (but not via task
runtime environments - event handlers are not called by tasks).

\subparagraph[EVENT handler]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ EVENT handler}

A list of one or more event handlers to call when one of the following EVENTs occurs:
\begin{myitemize}
    \item {\bf submitted}      - the job submit command was successful
    \item {\bf submission failed}  - the job submit command failed, or the
                                   submitted job was killed before it started executing
    \item {\bf submission retry}   - job submit failed, but cylc will resubmit it
                                   after a configured delay
    \item {\bf submission timeout} - the submitted job timed out without commencing execution

    \item {\bf started}        - the task reported commencement of execution
    \item {\bf succeeded}      - the task reported that it completed successfully
    \item {\bf failed}         - the task reported that if tailed to complete successfully
    \item {\bf retry}          - the task failed, but cylc will resubmit it
                                  after a configured delay
    \item {\bf execution timeout}        - the task timed out after execution commenced
    \item {\bf warning}        - the task reported a warning priority message
\end{myitemize}

Item details:
\begin{myitemize}
    \item {\em type:} string list (event handler scripts)
    \item {\em default:} None
    \item {\em example:} \lstinline@failed handler = my-failed-handler.sh@
\end{myitemize}

\subparagraph[submission timeout]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ submission timeout}

If a task has not started after the specified ISO 8601 duration/interval, the
{\em submission timeout} event handler(s) will be called.
\begin{myitemize}
    \item {\em type:} ISO 8601 duration/interval representation (e.g.
 \lstinline=PT30M=, 30 minutes or \lstinline=P1D=, 1 day).
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[execution timeout]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ execution timeout}

If a task has not finished after the specified ISO 8601 duration/interval, the
{\em execution timeout} event handler(s) will be called.
\begin{myitemize}
    \item {\em type:} ISO 8601 duration/interval representation (e.g.
 \lstinline=PT4H=, 4 hours or \lstinline=P1D=, 1 day).
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[reset timer]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ reset timer}

If you set an execution timeout the timer can be reset to zero every
time a message is received from the running task (which indicates the
task is still alive).  Otherwise, the task will timeout if it does not
finish in the alotted time regardless of incoming messages.

\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} False
\end{myitemize}

\paragraph[{[[[}environment{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment]]]}

The user defined task execution environment. Variables defined here can
refer to cylc suite and task identity variables, which are exported
earlier in the task job script, and variable assignment expressions can
use cylc utility commands because access to cylc is also configured
earlier in the script.  See also~\ref{TaskExecutionEnvironment}.

\subparagraph[\_\_VARIABLE\_\_ ]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment]]] $\rightarrow$ \_\_VARIABLE\_\_}
\label{AppendixTaskExecutionEnvironment}

Replace \_\_VARIABLE\_\_ with any number of environment variable
assignment expressions.
Order of definition is preserved so values can refer to previously
defined variables. Values are passed through to the task job script
without evaluation or manipulation by cylc, so any variable assignment
expression that is legal in the job submission shell can be used.
White space around the `$=$' is allowed (as far as cylc's suite.rc
parser is concerned these are just normal configuration items).

\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\item {\em legal values:} depends to some extent on the task job
    submission shell (\ref{JobSubShell}).
\item {\em examples}, for the bash shell:
   \begin{myitemize}
       \item \lstinline@FOO = $HOME/bar/baz@
       \item \lstinline@BAR = ${FOO}$GLOBALVAR@
       \item \lstinline@BAZ = $( echo "hello world" )@
       \item \lstinline@WAZ = ${FOO%.jpg}.png@
       \item \lstinline@NEXT_CYCLE = $( cylc cycle-point --offset=PT6H )@
       \item \lstinline@PREV_CYCLE = `cylc cycle-point --offset=-PT6H`@
       \item \lstinline@ZAZ = "${FOO#bar}" # <-- QUOTED to escape the suite.rc comment character@
   \end{myitemize}
\end{myitemize}

\paragraph[{[[[}environment filter{]]]}]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment filter]]]}
\label{EnvironmentFilter}

This section contains environment variable inclusion and exclusion
lists that can be used to filter the inherited environment. {\em This is
not intended as an alternative to a well-designed inheritance hierarchy
that provides each task with just the variables it needs.} Filters can,
however, improve suites with tasks that inherit a lot of environment
they don't need, by making it clear which tasks use which variables.
They can optionally be used routinely as explicit ``task environment
interfaces'' too, at some cost to brevity, because they guarantee that
variables filtered out of the inherited task environment are not used.

Note that environment filtering is done after inheritance is completely
worked out, not at each level on the way, so filter lists in higher-level
namespaces only have an effect if they are not overridden by descendants.

\subparagraph[include]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment filter]]] $\rightarrow$ include}

If given, only variables named in this list will be included from the
inherited environment, others will be filtered out. Variables may also
be explicitly excluded by an \lstinline=exclude= list.

\begin{myitemize}
\item {\em type:} string list
\item {\em default:} (none)
\end{myitemize}

\subparagraph[exclude]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment filter]]] $\rightarrow$ exclude}

Variables named in this list will be filtered out of the inherited
environment.  Variables may also be implicitly excluded by
omission from an \lstinline=include= list.

\begin{myitemize}
\item {\em type:} string list
\item {\em default:} (none)
\end{myitemize}

\paragraph[{[[[}directives{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[directives]]]}

Batch queue scheduler directives.  Whether or not these are used depends
on the job submission method. For the built-in methods that support directives
(\lstinline=loadleveler=, \lstinline=lsf=, \lstinline=pbs=, \lstinline=sge=,
\lstinline=slurm=), directives are written to the top of the task job script
in the correct format for the method. Specifying directives individually like
this allows use of default directives that can be individually overridden at
lower levels of the runtime namespace hierarchy.

\subparagraph[\_\_DIRECTIVE\_\_ ]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[directives]]] $\rightarrow$ \_\_DIRECTIVE\_\_}

Replace \_\_DIRECTIVE\_\_ with each directive assignment, e.g.
\lstinline@class = parallel@

\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\end{myitemize}

Example directives for the built-in job submission methods are shown
in~\ref{AvailableMethods}.

\paragraph[{[[[}outputs{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[outputs]]]}

This section is for registering custom message outputs that other tasks can
trigger off instead of the standard triggers. The task implementation must send
corresponding messages using the \lstinline=cylc task message= command at the
appropriate time. See~\ref{MessageTriggers} for more information.

\subparagraph[\_\_OUTPUT\_\_ ]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[outputs]]] $\rightarrow$ \_\_OUTPUT\_\_}

Replace \_\_OUTPUT\_\_ with one or more labelled output messages, and use the
labels in graph trigger notation.  Messages should contain a placeholder for
the current cycle point (\lstinline=[]=) or some offset from it (e.g.\ \lstinline=[-P2M]=).
\begin{myitemize}
    \item {\em type:} string
    \item {\em default:} (none)
    \item{ \em examples:}
\end{myitemize}
\begin{lstlisting}
foo = "sea state products ready for []"
bar = "nwp restart files ready for [-PT6H]"
\end{lstlisting}
See~\ref{MessageTriggers} for more information.

\paragraph[{[[[}suite state polling{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[suite state polling]]]}

\lstset{language=transcript}
Configure automatic suite polling tasks as described
in~\ref{SuiteStatePolling}. The
items in this section reflect the options and defaults of the
\lstinline=cylc suite-state= command, except that the target suite name and the
\lstinline=--task=, \lstinline=--cycle=, and \lstinline=--status= options are
taken from the graph notation.

\subparagraph[run-dir]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[suite state polling]]] $\rightarrow$ run-dir}

For your own suites the run database location is determined by your
site/user config. For other suites, e.g. those owned by others, or
mirrored suite databases, use this item to specify the location
of the top level cylc run directory (the database should be a
suite-name sub-directory of this location).

\begin{myitemize}
    \item {\em type:} string (a directory path on the target suite host)
    \item {\em default:} as configured by site/user config (for your own suites)
\end{myitemize}

\subparagraph[interval]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[suite state polling]]] $\rightarrow$ interval}

Polling interval expressed as an ISO 8601 duration/interval.
\begin{myitemize}
    \item {\em type:} ISO 8601 duration/interval representation (e.g.
 \lstinline=PT10S=, 10 seconds, or \lstinline=PT1M=, 1 minute).
    \item {\em default:} PT1M
\end{myitemize}

\subparagraph[max-polls]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[suite state polling]]] $\rightarrow$ max-polls}

The maximum number of polls before timing out and entering the `failed' state.

\begin{myitemize}
    \item {\em type:} integer
    \item {\em default:} 10
\end{myitemize}

\subparagraph[user]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[suite state polling]]] $\rightarrow$ user}

Username of an account on the suite host to which you have access. The
polling \lstinline=cylc suite-state= command will be invoked
on the remote account.

\begin{myitemize}
    \item {\em type:} string (username)
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[host]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[suite state polling]]] $\rightarrow$ host}

The hostname of the target suite. The polling \lstinline=cylc suite-state= command
will be invoked on the remote account.

\begin{myitemize}
    \item {\em type:} string (hostname)
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[verbose]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[suite state polling]]] $\rightarrow$ verbose}

Run the polling \lstinline=cylc suite-state= command in verbose output mode.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsection{[visualization]}

Configuration of suite graphing for the \lstinline=cylc graph= command (graph
extent, styling, and initial family-collapsed state) and the gcylc graph view
(initial family-collapsed state). Graphviz documentation of node shapes
and so on can be found at http://www.graphviz.org/Documentation.php.

\subsubsection[initial cycle point]{[visualization] $\rightarrow$ initial cycle point}

The initial cycle point for graph plotting.
\begin{myitemize}
    \item {\em type:} ISO 8601 date/time representation (e.g. CCYYMMDDThhmm)
    \item {\em default:} the suite initial cycle point
\end{myitemize}
The visualization initial cycle point gets adjusted up if necessary to the
suite initial cycling point.

\subsubsection[final cycle point]{[visualization] $\rightarrow$ final cycle point}

An explicit final cycle point for graph plotting. If used, this overrides the
preferred {\em number of cycle points} (below).
\begin{myitemize}
    \item {\em type:} ISO 8601 date/time representation (e.g. CCYYMMDDThhmm)
    \item {\em default:} (none)
\end{myitemize}
The visualization final cycle point gets adjusted down if necessary to the
suite final cycle point.

\subsubsection[number of cycle points]{[visualization] $\rightarrow$ number of cycle points}

The number of cycle points to graph starting from the visualization initial
cycle point. This is the preferred way of defining the graph end point, but
it can be overridden by an explicit {\em final cycle point} (above).
\begin{myitemize}
    \item {\em type:} integer
    \item {\em default:} 3
\end{myitemize}

\subsubsection[collapsed families]{[visualization] $\rightarrow$ collapsed families}

A list of family (namespace) names to be shown in the collapsed state
(i.e.\ the family members will be replaced by a single family node) when
the suite is first plotted in the graph viewer or the gcylc graph view.
If this item is not set, the default is to collapse all families at first.
Interactive GUI controls can then be used to group and ungroup family
nodes at will.

\begin{myitemize}
    \item {\em type:} list of family names
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[use node color for edges]{[visualization] $\rightarrow$ use node color for edges}

Graph edges (dependency arrows) can be plotted in the same color
as the upstream node (task or family) to make paths through a complex
graph easier to follow.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} True
\end{myitemize}

\subsubsection[use node color for labels]{[visualization] $\rightarrow$ use node color for labels}

Graph node labels can be printed in the same color as the node outline.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}


\subsubsection[default node attributes]{[visualization] $\rightarrow$ default node attributes}

Set the default attributes (color and style etc.) of graph nodes (tasks and families).
Attribute pairs must be quoted to hide the internal \lstinline@=@ character.

\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} \lstinline@'style=filled', 'fillcolor=yellow', 'shape=box'@
\end{myitemize}

\subsubsection[default edge attributes]{[visualization] $\rightarrow$ default edge attributes}

Set the default attributes (color and style etc.) of graph edges
(dependency arrows).  Attribute pairs must be quoted to hide the
internal \lstinline@=@ character.
\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} \lstinline@'color=black'@
\end{myitemize}

\subsubsection[{[[}node groups{]]}]{[visualization] $\rightarrow$ [[node groups]]}

Define named groups of graph nodes (tasks and families) which can styled
en masse, by name, in [visualization] $\rightarrow$ [[node attributes]].
Node groups are automatically defined for all task families, including
root, so you can style family and member nodes at once by family name.

\paragraph[\_\_GROUP\_\_]{[visualization] $\rightarrow$ [[node groups]] $\rightarrow$ \_\_GROUP\_\_}

Replace \_\_GROUP\_\_ with each named group of tasks or families.

\begin{myitemize}
    \item {\em type:} comma separated list of task or family names
    \item {\em default:} (none)
    \item {\em example:}
\begin{lstlisting}
   PreProc = foo, bar
   PostProc = baz, waz
\end{lstlisting}
\end{myitemize}

\subsubsection[{[[}node attributes{]]}]{[visualization] $\rightarrow$ [[node attributes]]}

Here you can assign graph node attributes to specific nodes, or to all
members of named groups defined in [visualization] $\rightarrow$ [[node
groups]]. Task families are automatically node groups. Styling of a
family node applies to all member nodes (tasks and sub-families), but
precedence is determined by ordering in the suite definition.  For
example, if you style a family red and then one of its members green,
cylc will plot a red family with one green member; but if you style one
member green and then the family red, the red family styling will
override the earlier green styling of the member.

\paragraph[\_\_NAME\_\_]{[visualization] $\rightarrow$ [[node attributes]] $\rightarrow$ \_\_NAME\_\_}

Replace \_\_NAME\_\_ with each node or node group for style attribute
assignment.

\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} (none)
    \item {\em example:} (with reference to the node groups defined above)
\begin{lstlisting}
   PreProc = 'style=filled', 'fillcolor=orange'
   PostProc = 'color=red'
   foo = 'style=filled'
\end{lstlisting}
\end{myitemize}
