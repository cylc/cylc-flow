\section{Suite.rc Reference}
\label{SuiteRCReference}

\lstset{language=bash}

This appendix documents legal content of raw cylc suite.rc files.
Many items have sensible default values, and most suites may only need to
explicitly configure a few of them.

In addition to the configuration items described below, Jinja2 expressions can
also be embedded to programmatically generate the final suite definition seen
by cylc.  Use of Jinja2 is documented in Section~\ref{Jinja2}.

See also {\em Suite Definition - Suite.rc Overview}
(Section~\ref{SuiteRCFile}) for a descriptive overview of suite.rc
files.

\subsection{Top Level Items}

The only top level configuration items at present are the suite title
and description.

\subsubsection{title}

The suite title is displayed in the gcylc suite database window. It can
also be retrieved from a suite at run time with \lstinline=cylc show= 
(or use \lstinline=cylc get-config=).

\begin{myitemize}
\item {\em type:} string 
\item {\em default:} ``No title provided''
\end{myitemize}

\subsubsection{description}

The suite description can be retrieved by gcylc right-click menu. It 
can also be retrieved from a suite at run time with 
\lstinline=cylc show= (or use \lstinline=cylc get-config=).

\begin{myitemize}
\item {\em type:} string
\item {\em default:} ``No description provided''
\end{myitemize}

\subsection{[cylc]}

This section is for suite configuration that is not specifically
task-related.

\subsubsection[UTC mode]{ [cylc] $\rightarrow$ UTC mode}

Cylc runs off the suite host's system clock by default. This item allows
you to run the suite in UTC even if the system clock is set to local time.
Clock-triggered tasks will trigger when the current UTC time is equal to
their cycle time plus offset; other time values used, reported, or
logged by cylc will also be in UTC. 

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False 
\end{myitemize}

\subsubsection[simulation mode only]{ [cylc] $\rightarrow$ simulation mode only}

This prevents a suite from running in real mode - use for demo suites
created by copying real suites out of their normal operating environment.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[max simultaneous job submissions]{[cylc] $\rightarrow$ max simultaneous job submission}

This sets the maximum allowable number of simultaneous (parallel) job
submissions. If a greater number of tasks than this happen to become
ready to run at once (as would be typical for ensemble suites), cylc
will submit them in batches of this size, waiting for all members of a
batch to return before proceeding to the next batch.  See
Section~\ref{MaxSimJobSub}.

\begin{myitemize}
    \item {\em type:} integer (minimum 1)
    \item {\em default:} 50
\end{myitemize}

\subsubsection[pyro connection timeout]{[cylc] $\rightarrow$ pyro connection timeout}

This sets the network connection timeout for Pyro connections to a
running suite. The default is no timeout at all. See
Section~\ref{MaxSimJobSub} for more on why this matters.

\begin{myitemize}
    \item {\em type:} float (seconds; minimum 0.0)
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[abort if any task fails]{[cylc] $\rightarrow$ abort if any task fails}

Cylc does not normally abort if tasks fail, but if this item is turned
on it will abort with exit status 1 if any task fails.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[directory]{[cylc] $\rightarrow$ [[logging]] $\rightarrow$ directory}

The cylc log and its backups are stored in this directory. If you change
the directory make sure it remains suite-specific by using suite
identity environment variables in the path.

\begin{myitemize}
    \item {\em type:} string (directory path, may contain environment variables)
    \item {\em default:} \lstinline=$HOME/cylc-run/$CYLC_SUITE_REG_NAME/log/suite=
\end{myitemize}

\paragraph[roll over at start-up]{[cylc] $\rightarrow$ [[logging]] $\rightarrow$ roll over at start-up}

Suite logs roll over (start anew) automatically when they reach a
certain size - currently hardwired to 1MB in
\lstinline=$CYLC_DIR/lib/cylc/pimp_my_logger.py=. 
They can also be rolled automatically whenever a
suite is started or restarted.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} True
\end{myitemize}


\subsubsection[{[[}logging{]]} ]{[cylc] $\rightarrow$ [[logging]]}

This section configures cylc's logging functionality, which records
time-stamped events to a special log file. 

\paragraph[directory]{[cylc] $\rightarrow$ [[logging]] $\rightarrow$ directory}

The cylc log and its backups are stored in this directory. If you change
the directory make sure it remains suite-specific by using suite
identity environment variables in the path.

\begin{myitemize}
    \item {\em type:} string (directory path, may contain environment variables)
    \item {\em default:} \lstinline=$HOME/cylc-run/$CYLC_SUITE_REG_NAME/log/suite=
\end{myitemize}

\paragraph[roll over at start-up]{[cylc] $\rightarrow$ [[logging]] $\rightarrow$ roll over at start-up}

Suite logs roll over (start anew) automatically when they reach a
certain size - currently hardwired to 1MB in
\lstinline=$CYLC_DIR/lib/cylc/pimp_my_logger.py=. 
They can also be rolled automatically whenever a
suite is started or restarted.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} True
\end{myitemize}

\subsubsection[{[[}state dumps{]]}]{ [cylc] $\rightarrow$ [[state dumps]] }

 State dump files allow cylc to restart suites from previous states of
 operation. 

\paragraph[directory]{[cylc] $\rightarrow$ [[state dumps]] $\rightarrow$ directory}

 The rolling archive of suite state dump files, backups of the default 
 state dump, and any special pre-intervention state dumps, are stored
 under this directory.  If you change this directory make sure it
 remains suite-specific by using suite identity environment variables in
 the path.

\begin{myitemize}
    \item {\em type:} string (directory path, may contain environment variables)
    \item {\em default:} \lstinline=$HOME/cylc-run/$CYLC_SUITE_REG_NAME/state=
\end{myitemize}

\paragraph[number of backups]{[cylc] $\rightarrow$ [[state dumps]] $\rightarrow$ number of backups}

This is the length, in number of changes, of the automatic rolling
archive of state dump files that allows you to restart a suite from a
previous state.  Every time a task changes state cylc updates the state
dump and rolls previous states back one on the archive.  You'll probably
only ever need the latest (most recent) state dump, which is
automatically used in a restart, but any previous state still in the
archive can be used.  Additionally, special labeled state dumps are
written out prior to actioning any suite intervention - their filenames
are logged by cylc.

\begin{myitemize}
    \item {\em type:} integer ($\geq 1$)
    \item {\em default:} $10$
\end{myitemize}

\subsubsection[{[[}event hooks{]]}]{[cylc] $\rightarrow$ [[event hooks]]}
\label{SuiteEventHandling}

Cylc can call a nominated handler when certain suite events occur.
Event handlers can send an email or an SMS, call a pager, and so on; or
intervene in the operation of their own suite using cylc commands. The
command \lstinline=cylc [hook] email-suite= is a ready-made suite event
handler.

A single script can be nominated to handle a list of chosen events, and
the event name is passed to the handler to allow it to distinguish
between them.

Custom suite event handlers can be located in the suite bin directory.
They are passed the following arguments by cylc:

\begin{lstlisting}
<hook-script> EVENT SUITE MESSAGE
\end{lstlisting}
where EVENT is one of the following strings:
\begin{myitemize}
    \item `shutdown' - the suite stopped, normally or not. 
    \item `timeout' - the suite timed out
\end{myitemize}
MESSAGE, if provided, describes what has happened.

{\em Note that event handlers are called by cylc itself} so if you wish
to pass them additional information via the environment you must use
[cylc] $\rightarrow$ [[environment]], not task runtime environments
(suite-level variables - \lstinline=$CYLC_SUITE_INITIAL_CYCLE_TIME=
etc.\ - are exported into the suite environment, however).

To configure suite timeout handling put `timeout' in the event list and
specify corresponding timeout values in minutes for the timeout item
below.

See also Section~\ref{TaskEventHandling} for task event hooks.

\paragraph[events]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ events }

The list of events to handle, as documented for EVENT just above.
\begin{myitemize}
    \item {\em type:} list of strings
    \item {\em default:} (none)
\end{myitemize}


\paragraph[script]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ script}

The handler script to call when one of the nominated events occurs.

\begin{myitemize}
    \item {\em type:} string
    \item {\em default:} (none)
\end{myitemize}

\paragraph[timeout]{[cylc] $\rightarrow$ [[[event hooks]]] $\rightarrow$ timeout}

If a timeout is set and the timeout event is handled the event
handler will be called if the suite times out before it finishes.
See also ``abort on timeout'', below.

\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} (none)
\end{myitemize}


\paragraph[script]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ abort if shutdown handler fails}

Cylc does not normally care whether a shutdown handler, executed just
prior to shutting down, succeeds or fails; but if this is turned on 
cylc will execute the shutdown handler in the foreground and the suite
will abort with error status if the handler script fails. This feature
is used by cylc test suites that diagnose their own logs with shutdown
handlers.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[script]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ abort on timeout}

If a suite timer is set (above) this will cause the suite to abort with
error status if the suite times out while still running. This feature
is used by cylc test suites to catch any error that prevents a suite
from completing.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[{[[}lockserver{]]}]{[cylc] $\rightarrow$ [[lockserver]]}

The cylc lockserver brokers suite and task locks on the network (these
are somewhat analagous to traditional local {\em lock files}). It
prevents multiple instances of a suite or task from being invoked 
at the same time (via scheduler instances or \lstinline=cylc submit=).
 
See \lstinline=cylc lockserver --help= for 
how to run the lockserver, and \lstinline=cylc lockclient --help= for 
occasional manual lock management requirements. 

\paragraph[enable]{[cylc] $\rightarrow$ [[lockserver]] $\rightarrow$ enable}

The lockserver is currently disabled by default. It is intended mainly for
operational use.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[simultaneous instances]{[cylc] $\rightarrow$ [[lockserver]] $\rightarrow$ simultaneous instances}

By default the lockserver prevents multiple simultaneous instances of a
suite from running even under different registered names. But allowing
this may be desirable if the I/O paths of every task in the suite are
dynamically configured to be suite specific (and similarly for the suite
state dump and logging directories, by using suite identity variables in
their directory paths). Note that {\em the lockserver cannot protect you
from running multiple distinct {\bf copies} of a suite simultaneously}. 

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[{[[}environment{]]} ]{[cylc] $\rightarrow$ [[environment]]}

Variables defined here are exported into the environment in which cylc
itself runs. They are then available to {\em local processes spawned
directly by cylc}. Any variables read by task event handlers must be
defined here, for instance, because event handlers are executed
directly by cylc, not by running tasks. And similarly the {command
lines} issued by cylc to invoke event handlers or to submit task 
job scripts could, in principle, make use of environment variables
defined here. 
\paragraph{Warnings}

\begin{myitemize}
    \item Cylc local variables are not available to
        executing tasks unless you happen to choose a local direct job
        submission method.  {\em Always use task runtime environments to
        pass variables into the task execution environment
        (\ref{AppendixTaskExecutionEnvironment}).}
    \item Unlike task execution environment variables, which are written
        to job scripts and interpreted by the shell at run time, 
        cylc local environment variables are written directly 
        to the environment by Python as literal strings {\em  so 
        shell variable expansion expressions cannot be used here.}
\end{myitemize}

\paragraph[\_\_VARIABLE\_\_ ]{[cylc] $\rightarrow$ [[environment]] $\rightarrow$ \_\_VARIABLE\_\_}

Replace \_\_VARIABLE\_\_ with any number of environment variable
assignment expressions.
Values may refer to other local environment variables (order of
definition is preserved) and are not evaluated or manipulated by 
cylc, so any variable assignment expression that is legal in the 
shell in which cylc is running can be used (but see the warning 
above on variable expansions, which will not be evaluated).
White space around the `$=$' is allowed (as far as cylc's suite.rc 
parser is concerned these are normal configuration items).

\begin{myitemize}
    \item {\em type:} string
    \item {\em default:} (none)
    \item {\em examples:} 
        \begin{myitemize}
            \item \lstinline@FOO = $HOME/foo@
        \end{myitemize}
\end{myitemize}

\subsubsection[{[[}simulation mode{]]}]{[cylc] $\rightarrow$ [[simulation mode]] }

Items specific to running suites in simulation mode.

\paragraph[clock rate]{[cylc] $\rightarrow$ [[simulation mode]] $\rightarrow$ clock rate}

This determines the speed at which the simulation mode clock runs, in 
real seconds per simulated hour. A value of 10, for example, means it
will take 10 real seconds to simulate one hour of operation.

\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, real seconds per simulated hour)
    \item {\em default:} $10$
\end{myitemize}

\paragraph[clock offset]{[cylc] $\rightarrow$ [[simulation mode]] $\rightarrow$ clock offset}

The clock offset determines the initial time on the simulation clock, 
at suite startup, relative to the initial cycle time.  An offset of
$0$ simulates real time operation; greater offsets simulate catch up
from a delay and subsequent transition to real time operation.

\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, hours behind initial cycle time)
    \item {\em default:} $24$
\end{myitemize}

\paragraph[command scripting]{ [cylc] $\rightarrow$ [[simulation mode]] $\rightarrow$ command scripting}

The command scripting to execute for all tasks when running in simulation mode.
\begin{myitemize}
\item {\em type:} string (scripting valid in job submission shell;
    triple quote for multiple lines)
\item {\em default:} \lstinline=echo SIMULATION MODE $CYLC_TASK_ID; sleep 10; echo BYE=
\end{myitemize}

\paragraph[{[[[}job submission{]]]} ]{[cylc] $\rightarrow$ [[simulation mode]] $\rightarrow$ [[[job submission]]]} 

Configure job submission for simulation mode.

\subparagraph[method]{[cylc] $\rightarrow$ [[simulation mode]] $\rightarrow$ [[[job submission]]] $\rightarrow$ method } 

The job submission method to use for all tasks in simulation mode. Any 
available method can be used but the default is probably sufficient for simulation mode.

\begin{myitemize}
    \item {\em type:} string (a job submission method name - see Section~\ref{RuntimeJobSubMethods})
    \item {\em default:} \lstinline=background=
\end{myitemize}

\paragraph[{[[[}event hooks{]]]} ]{[cylc] $\rightarrow$ [[simulation mode]] $\rightarrow$ [[[event hooks]]]} 

Configure event hooks for simulation mode.

\subparagraph[enable]{[cylc] $\rightarrow$ [[simulation mode]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ enable } 

Event hooks are disabled by default in simulation mode. They can be
enabled in order to test automated alerts, for example, without
running the real suite tasks, but be aware that timeouts will be 
relative to the accelerated simulation mode clock which by default runs
very quickly.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsection{[scheduling]}

This section allows cylc to determine when tasks are ready to run.

\subsubsection[initial cycle time]{[scheduling] $\rightarrow$ initial cycle time}

At startup each cycling task (unless specifically excluded under
[special tasks]) will be inserted into the suite with this cycle time,
or with the closest subsequent valid cycle time for the task. Note that
whether or not {\em cold-start tasks}, specified under [special tasks],
are inserted, and in what state they are inserted, depends on the start
up method - cold, warm, or raw.  If this item is provided you can 
override it on the command line or in the gcylc suite start panel.

\begin{myitemize}
    \item {\em type:} integer (YYYY[MM[DD[HH[mm[ss]]]]])
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[final cycle time]{[scheduling] $\rightarrow$ final cycle time}

Cycling tasks are held (i.e.\ not allowed to spawn a successor) once they
pass the final cycle time, if one is specified. Once all tasks have
achieved this state the suite will shut down. If this item is provided you 
can override it on the command line or in the gcylc suite start panel.

\begin{myitemize}
    \item {\em type:} integer (YYYY[MM[DD[HH[mm[ss]]]]])
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[runahead limit]{[scheduling] $\rightarrow$ runahead limit}

The suite runahead limit prevents the fastest tasks in a suite from
getting too far ahead of the slowest ones, as documented in
Section~\ref{RunaheadLimit}. Tasks exceeding the limit will be put into
a special runahead held state until slower tasks have caught up
sufficiently. The limit must be long enough to cover the minimum cycle
time range of tasks present in the suite: a task that only runs once per
day, for instance, needs to spawn 24 hours ahead.  Failed tasks, which
are not automatically removed from a suite, are ignored when computing
the runahead limit. 
\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, hours)
    \item {\em default:} $24$
\end{myitemize}

\subsubsection[{[[}queues{]]}]{[scheduling] $\rightarrow$ [[queues]]}

Configuration of internal queues, by which the number of simultaneously
active tasks (submitted or running) can be limited, per queue. By
default a single queue called {\em default} is defined, with all tasks 
assigned to it and no limit. To use a single queue for the whole suite 
just set the limit on the {\em default} queue as required.
See also Section~\ref{InternalQueues}.

\paragraph[{[[[}\_\_QUEUE\_\_{]]]}]{[scheduling] $\rightarrow$ [[queues]] $\rightarrow$ [[[\_\_QUEUE\_\_]]]}

Section heading for configuration of a single queue. Replace
\_\_QUEUE\_\_ with a queue name, and repeat the section as required.

\begin{myitemize}
\item {\em type:} string
\item {\em default:} ``default''
\end{myitemize}

\paragraph[limit]{[scheduling] $\rightarrow$ [[queues]] $\rightarrow$ [[[\_\_QUEUE\_\_]]] $\rightarrow$ limit}

The maximum number of active tasks allowed at any one time, for this queue.
\begin{myitemize}
\item {\em type:} integer
\item {\em default:} 0 (i.e.\ no limit)
\end{myitemize}

\paragraph[members]{[scheduling] $\rightarrow$ [[queues]] $\rightarrow$ [[[\_\_QUEUE\_\_]]] $\rightarrow$ members}

A list of member tasks, or task family names, to assign to this queue
(assigned tasks will automatically be removed from the default queue).
\begin{myitemize}
\item {\em type:} list of strings
\item {\em default:} none for user-defined queues; all tasks for the ``default'' queue
\end{myitemize}

\subsubsection[{[[}special tasks{]]}]{[scheduling] $\rightarrow$ [[special tasks]]}

This section identifies any tasks with special behaviour. By default
(i.e.\ non ``special'' behaviour) tasks submit (or queue) as soon as
their prerequisites are satisfied, and they spawn a successor at the
next valid cycle time for the task as soon as they enter the submitted 
state\footnote{Spawning any earlier than this brings no advantage in
terms of functional parallelism and would cause uncontrolled
proliferation of waiting tasks.}

\paragraph[clock-triggered]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ clock-triggered}

Clock-triggered tasks wait on a wall clock time specified as an offset
{\em in hours} relative to their own cycle time, in addition to any
dependence they have on other tasks. Generally speaking, only tasks that
wait on external real time data need to be clock-triggered.  Note that
in computing the trigger time the full wall clock time and cycle time
are compared, not just hours and minutes of the day, so when running a
suite in catchup/delayed operation, or over historical periods,
clock-triggered tasks will not constrain the suite at all until they
catch up to the wall clock.

\begin{myitemize}
    \item {\em type:} list of tasknames with offsets (hours, positive or negative)
    \item {\em default:} (none)
    \item {\em example:} \lstinline@clock-triggered = foo(1.5), bar(2.25)@
\end{myitemize}

\paragraph[start-up]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ start-up}

Start-up tasks are one-off tasks (they do not spawn a successor) that
only run in the first cycle (and only in a cold-start) and any
dependence on them is ignored in subsequent cycles. They can be used to
prepare a suite workspace, for example, before other tasks run. Start-up
tasks cannot appear in conditional trigger expressions with normal
cycling tasks, because the meaning of the conditional expression becomes
undefined in subsequent cycles. 

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[cold-start]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ cold-start}

A cold-start task is one-off task used to satisfy the dependence of an
associated task with the same cycle time, on outputs from a previous
cycle - when those outputs are not available.  The primary use for this
is to cold-start a warm-cycled forecast model that normally depends on
restart files (e.g.\ model background fields) generated by its previous
forecast, when there is no previous forecast.  This is required when
cold-starting the suite, but cold-start tasks can also be inserted into
a running suite to restart a model that has had to skip some cycles
after running into problems. Cold-start tasks can invoke real cold-start
processes, or they can just be dummy tasks that represent some external
process that has to be completed before the suite is started. Unlike
{\em start-up} tasks, dependence on cold-start tasks is preseverved in
subsequent cycles so they must typically be used in OR'd conditional
expressions to avoid holding up the suite.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[sequential]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ sequential}

By default, a task spawns a successor as soon as it is submitted to run
so that successive instances of the same task can run in parallel if the
opportunity arises (i.e.\ if their prerequisites happen to be satisfied
before their predecessor has finished). {\em Sequential tasks}, however,
will not spawn a successor until they have finished successfully. This
should be used for (a) {\em tasks that cannot run in parallel with their
own previous instances} because they would somehow interfere with each
other (use cycle time in all I/O paths to avoid this); and (b) {\em warm
cycled forecast models that write out restart files for multiple cycles
ahead} (exception: see ``explicit restart outputs''
below).\footnote{This is because you don't want Model[T] waiting around
to trigger off Model[T-12] if Model[T-6] has not finished yet. If Model
is forced to be sequential this can't happen because Model[T] won't
exist in the suite until Model[T-6] has finished. But if Model[T-6]
fails, it can be spawned-and-removed from the suite so that Model[T] can
{\em then} trigger off Model[T-12], which is the correct behaviour.} 

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[one-off]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ one-off}

Synchronous one-off tasks have an associated cycle time but do not spawn
a successor. Synchronous {\em start-up} and {\em cold-start} tasks are
automatically one-off tasks and do not need to be listed here.
Dependence on one-off tasks is not restricted to the first cycle.

\begin{myitemize}
\item {\em type:} list of task names
\item {\em default:} (none)
\end{myitemize}

\paragraph[explicit restart outputs]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ explicit restart outputs}

% TO DO: THESE TASKS COULD BE IDENTIFIED FROM THE GRAPH?

This is only required in the event that you need a warm cycled forecast
model to start at the instant its restart files are ready (if other
prerequisites are satisfied) {\em even if its previous instance has
not finished yet}.  If so, the model task has to depend on special
output messages emitted by the previous instance as soon as its restart
files are ready, instead of just on the previous instance finishing.
{\em Tasks in this category must define special restart
output messages containing the word ``restart''}, in
[runtime] $\rightarrow$ [[TASK]] $\rightarrow$ [[[outputs]]] - see
Section~\ref{RIOC}.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[exclude at start-up]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ exclude at start-up}
\label{EASU}

Any task listed here will be excluded from the initial task pool (this
goes for suite restarts too). If an {\em inclusion} list is also
specified, the initial pool will contain only included tasks that have
not been excluded. Excluded tasks can still be inserted at run time.
Other tasks may still depend on excluded tasks if they have not been
removed from the suite dependency graph, in which case some manual
triggering, or insertion of excluded tasks, may be required.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[include at start-up]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ include at start-up}
\label{IASU}

If this list is not empty, any task {\em not} listed in it will be
excluded from the initial task pool (this goes for suite restarts too).
If an {\em exclusion} list is also specified, the initial pool will
contain only included tasks that have not been excluded. Excluded tasks
can still be inserted at run time. Other tasks may still depend on
excluded tasks if they have not been removed from the suite dependency
graph, in which case some manual triggering, or insertion of excluded 
tasks, may be required.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[{[[}dependencies{]]}]{[scheduling] $\rightarrow$ [[dependencies]]}

The suite dependency graph is defined under this section.  You can plot
the dependency graph as you work on it, with \lstinline=cylc graph= or
by right clicking on the suite in gcylc.  See also 
Section~\ref{DependencyGraphs}.

\paragraph[graph]{ [scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ graph }

The dependency graph for any one-off asynchronous (non-cycling) tasks in
the suite goes here. This can be used to construct a suite of one-off
tasks (e.g.\ build jobs and related processing) that just completes and
then exits, or an initial suite section that completes prior to the
cycling tasks starting (if you make the first cycling tasks depend on
the last one-off ones). But note that synchronous {\em start-up} tasks
can also be used for the latter purpose.  See Section~\ref{GraphDescrip}
below for graph string syntax, and Section~\ref{DependencyGraphs}.
\begin{myitemize}
    \item {\em type:} string 
    \item {\em example:} (see Section~\ref{GraphDescrip} below)
\end{myitemize}
 
\paragraph[{[[[}\_\_VALIDITY\_\_{]]]}]{[scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ [[[\_\_VALIDITY\_\_]]]}

Replace \_\_VALIDITY\_\_ with a comma-separated list of integer hours, 
$0\leq H \leq 23$,  defining the valid
cycle times for the subsequent graph of cycling tasks, or multiple such
subsections as required for different dependencies at different hours; 
or with `ASYNCID:{\em pattern}', where {\em pattern} is a regular
expression that matches an asynchronous task ID, for each graph of
repeating asynchronous tasks.

\begin{myitemize}
    \item {\em examples:} 
        \begin{myitemize} 
            \item (cycling tasks) \lstinline@[[0,6,12,18]]@ 
            \item (repeating asynchronous tasks) \lstinline@[[ASYNCID:SAT-\d+]]@ 
        \end{myitemize}
    \item {\em default:} (none)
\end{myitemize}
For a cycling graph with multiple validity sections for different
hours of the day, the different sections {\em add} to generate the
complete graph. Different graph sections can overlap (i.e.\ the same hours
may appear in multiple section headings) and the same tasks may appear
in multiple sections, but the individual dependencies must be unique
across the entire graph. Duplicate dependencies will cause a run time 
error at start-up, as documented in {\em How Multiple Graph Strings Combine} 
(Section~\ref{HowMultipleGraphStringsCombine}).

\subparagraph[graph]{[scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ [[[\_\_VALIDITY\_\_]]] $\rightarrow$ graph }
\label{GraphDescrip}

The dependency graph for the specified validity section (described just
above) goes here. Syntax examples follow; see also
Sections~\ref{DependencyGraphs} ({\em Dependency Graphs})
and~\ref{TriggerTypes} ({\em Trigger Types}). 

\begin{myitemize}
\item {\em type:} string 
\item {\em examples:}
  \begin{lstlisting}
graph = """
   foo => bar => baz & waz   # baz and waz both trigger off bar
   baz:out1 => faz           # faz triggers off an internal output of baz
   ColdFoo | foo[T-6] => foo # cold-start or restart for foo
   X:start => Y              # Y triggers if X starts executing
   X:fail => Y               # Y triggers if X fails
   foo[T-6]:fail => bar      # bar triggers if foo[T-6] fails
   X => !Y                   # Y suicides if X succeeds
   X | X:fail => Z           # Z triggers if X succeeds or fails
   X:finish => Z             # Z triggers if X succeeds or fails
   (A | B & C ) | D => foo   # general conditional triggers
   # comment
   """
  \end{lstlisting}
\item {\em default:} (none)
\end{myitemize}

\subparagraph[daemon]{[scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ [[[\_\_VALIDITY\_\_]]] $\rightarrow$ daemon }

For [[[ASYNCID:pattern]]] validity sections only, list 
{\em asynchronous daemon} tasks by name. This item is located here rather than
under [scheduling] $\rightarrow$ [[special tasks]] because a damon task
is associated with a particular asynchronous ID.

\begin{myitemize}
\item {\em type:} list of task names
\item {\em default:} (none)
\end{myitemize}

\subsection{[runtime]}

This section defines how, where, and what to execute when tasks are
ready to run. Runtime subsections define an inheritance hierarchy of 
{\em namespaces}, each of which represents a family of tasks or an
individual task, as described in Section~\ref{NIORP}).

\subsubsection[{[[}\_\_NAME\_\_{]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]]}

Replace \_\_NAME\_\_ with a namespace name, or a comma separated list of
names, and repeat as needed to define all tasks in the suite.

Namespace names may contain letters, digits, underscores, and hyphens.
They may not contain colons (which would preclude use of directory paths
involving the registration name in \lstinline=$PATH= variables). They 
may not contain the `.' character (it will be interpreted 
as the namespace hierarchy delimiter, separating groups and names). 
{\em Task names should not be hardwired into task implementations.}
Rather, task and suite identity should be extracted portably from the
task execution environment supplied by cylc 
(Section~\ref{TaskExecutionEnvironment}) - then to rename a task you
can just change its name in the suite.rc file.

A namespace represents a family if other namespaces inherit from it; it
represents a task if it is a leaf on the inheritance tree (i.e.\ no
other namespaces inherit from it).

\begin{myitemize}
\item {\em legal values:} 
    \begin{myitemize}
        \item \lstinline=[[foo]]=
        \item \lstinline=[[foo, bar, baz]]=
    \end{myitemize}
\end{myitemize}

If multiple names are listed, the subsequent namespace configuration
items apply to each member, but any instance of \lstinline=<TASK>= 
in any value will be replaced by cylc with the actual namespace name.
This can be used to define many tasks that are almost identical.

All namespaces inherit initially from {\em root}, which you can
explicitly configure to override or provide default runtime settings for
all tasks in the suite.

\paragraph[inherit]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ inherit}

Specify here the namepace from which this namespace should inherit all
of its runtime configuration; specific items can then be overridden
as required. Note that many of the available items are left undefined even
in the root namespace.

\begin{myitemize}
\item {\em type:} string (another namespace name)
\item {\em default:} root
\end{myitemize}

\paragraph[description]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ description}

A description of this namespace, retrievable from running tasks via 
\lstinline=cylc show=.
\begin{myitemize}
\item {\em type:} string 
\item {\em root default:} ``No description provided''
\end{myitemize}


\paragraph[initial scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ initial scripting}

Initial scripting is executed at the top of the task job script just
before the \lstinline=cylc task started= message call is made, and
before the task execution environment is configured - so it does not
have access to any suite or task environment variables.  The original
intention was to allow remote tasks to source login scripts before
calling the first cylc command, e.g.\ to set \lstinline=$PYTHONPATH= if
Pyro has been installed locally. Note however that the remote task
invocation mechanism now automatically sources both
\lstinline=/etc/profile= and \lstinline=$HOME/.profile= if they exist. 
For other uses pre-command scripting should be used if possible because
it can has access to the task execution environment.
\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\item {\em example:} \lstinline@initial scripting = "echo Hello World"@
\end{myitemize}

\paragraph[command scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ command scripting}

The scripting to execute when the associated task is ready to run - this
can be a single command or a multiline string of scripting. 

\begin{myitemize}
\item {\em type:} multiline string
\item {\em root default:} \lstinline=echo "Default command scripting: sleep 10..."; sleep 10=
\end{myitemize}

\paragraph[retry delays]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ retry delays}
\label{RefRetries}

A list of time intervals in minutes after which to resubmit the task if it 
fails. Before each try the variable \lstinline=$CYLC_TASK_TRY_NUMBER= is
incremented and passed to the task execution environment; this can be
used to alter the behaviour at each try.

\begin{myitemize}
\item {\em type:} list of floats
\item {\em example:} 1.5, 10, 10 10
\item {\em root default:} (none)
\end{myitemize}



\paragraph[pre-command scripting]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ pre-command scripting}

Scripting to be executed immediately {\em before} the command scripting.
This would typically be used to add scripting to every task in a family
(for individual tasks you could just incorporate the extra commands into
the main command scripting). See also {\em post-command scripting},
below.

\begin{myitemize}
\item {\em type:} string, or a list of strings
\item {\em default:} (none)
\item {\em example:} 
 \begin{lstlisting}
    pre-command scripting = """
      . $HOME/.profile
      echo Hello from suite ${CYLC_SUITE_REG_NAME}!"""
 \end{lstlisting}
\end{myitemize}

\paragraph[post-command scripting]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ post-command scripting}

Scripting to be executed immediately {\em after} the command scripting.
This would typically be used to add scripting to every task in a family
(for individual tasks you could just incorporate the extra commands into
the main command scripting). See also {\em pre-command scripting},
above.

\begin{myitemize}
\item {\em type:} string, or a list of strings
\item {\em default:} (none)
\end{myitemize}

\paragraph[manual completion]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ manual completion}

If a task's initiating process detaches and exits before task processing
is finished then cylc cannot arrange for the task to automatically
signal when it has succeeded or failed. In such cases you must use this 
configuration item to tell cylc not to arrange for automatic completion
messaging, and insert some minimal completion messaging yourself in
appropriate places in the task implementation (see
Section~\ref{DetachingTasks}).

\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} False
\end{myitemize}

% HIDDEN \paragraph[hours]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ hours}

% HIDDEN \paragraph[extra log files]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ extra log files}

\paragraph[enable resurrection]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ enable resurrection}

If a message is received from a failed task cylc will normally treat
this as an error condition, issue a warning, and leave the task in the
``failed'' state.  But if ``enable resurrection'' is switched on failed
tasks can come back from the dead: if the same task job script is
executed again cylc will put the task back into the running state and
continue as normal when the started message is received. This can be
used to handle HPC-style job preemption wherein a resource manager may
kill a running task and reschedule it to run again later, to make way
for a job with higher immediate priority. See also
Section~\ref{PreemptionHPC}, {\em Handling Job Preemption}
\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} \lstinline=False=
\end{myitemize}


\subparagraph[log directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ log directory}
\label{LocalLog}

This is where task job scripts, and the stdout and stderr logs for local
tasks, are written. The directory path may contain environment
variables, including suite identity variables to make the path
suite-specific (as the default value does) but {\em it may not 
contain task identity variables such as \lstinline=$CYLC_TASK_NAME= and
\lstinline=$CYLC_TASK_CYCLE_TIME= or any variables defined in the task
environment section} - the directory has to be created by cylc before
the task runs so the directory creation process does not see the task
execution environment.
%? Remote tasks must also define a [[[remote]]] log directory. 
%? For owned tasks, the suite owner's home directory is replaced by the
%? task owner's.
The job script filename is constructed, just before job submission,
from the task ID and {\em seconds since epoch}, and then {\em .out} and
{\em .err} are appended to construct the stdout and stderr log names,
respectively. These filenames are thus unique even if a task
gets retriggered and yet will be correctly time ordered if the log
directory is listed. The filenames are also recorded by the task proxies 
for access via cylc commands and the suite control GUIs.
\begin{myitemize}
\item {\em type:} string (directory path, may contain environment variables)
\item {\em default:} \lstinline=$HOME/cylc-run/$CYLC_SUITE_REG_NAME/log/job=
\end{myitemize}

\subparagraph[work directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ work directory}
\label{LocalWork}

Task command scripting is executed from within a work directory created
on the fly, if necessary, by the task's job script. In non-detaching
tasks the work directory is automatically removed again {\em if it is
empty} before the job script exits. The work directory can be accessed
by tasks via the environment variable \lstinline=$CYLC_TASK_WORK_PATH=.

\begin{myitemize}
\item {\em type:} string (directory path, may contain environment variables)
\item {\em default:} \lstinline=$CYLC_SUITE_DEF_PATH/work/$CYLC_TASK_ID=
\end{myitemize}

\subparagraph[share directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ share directory}
\label{LocalShare}

Like task work directories (above) this directory is created on the fly,
if necessary, by the job script. It is intended as a shared data area
for multiple tasks on the same host, but as for any task runtime config
item it can be specialized to particular tasks or groups of tasks. 
It can be accessed by tasks at run time via the environment variable
\lstinline=$CYLC_SUITE_SHARE_PATH=.

\begin{myitemize}
\item {\em type:} string (directory path, may contain environment variables)
\item {\em default:} \lstinline=$CYLC_SUITE_DEF_PATH/share=
\end{myitemize}


\paragraph[{[[[}job submission{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]]}

This section configures the means by which cylc submits task job scripts to run.

\subparagraph[method]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ method}
\label{RuntimeJobSubMethods}

See {\em Task Job Submission} (Section~\ref{TaskJobSubmission}) 
for how job submission works, and how to define new methods.
Cylc has a number of built in job submission methods:
\begin{myitemize}
\item {\em type:} string
\item {\em legal values:} 
   \begin{myitemize}
       \item {\em background} - direct background execution
       \item {\em at} - the rudimentary Unix \lstinline=at= scheduler
       \item {\em loadleveler} - \lstinline=llsubmit=, with directives defined in the suite.rc file 
       \item {\em pbs} - PBS \lstinline=qsub=, with directives defined in the suite.rc file 
       \item {\em sge} - Sun Grid Engine \lstinline=qsub=, with directives defined in the suite.rc file 
   \end{myitemize}
\item {\em default:} \lstinline=background=
\end{myitemize}

\subparagraph[command template]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ command template}

This allows you to override the actual command used by the chosen job
submission method. The template's first \%s will be substituted by the
job file path.  Where applicable the second and third \%s will be
substituted by the paths to the job stdout and stderr files.

\begin{myitemize}
\item {\em type:} string
\item {\em legal values:} a string template
\item {\em example:} \lstinline@llsubmit %s@
\end{myitemize}

\subparagraph[shell]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ shell}
\label{JobSubShell}

This is the shell used to interpret the job script submitted by cylc
when a task is ready to run.  {\em It has no bearing on the shell used
in task implementations.} Command scripting and suite environment 
variable assignment expressions must be valid for this shell. The 
latter is currently hardwired into cylc as 
\lstinline@export item=value@ - valid for both bash and ksh
because \lstinline=value= is entirely user-defined - but cylc would have
to be modified slightly to allow use of the C shell.

\begin{myitemize}
\item {\em type:} string
\item {\em root default:} \lstinline=/bin/bash= 
\end{myitemize}


\paragraph[{[[[}remote{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]]}

Remote hosting configuration for tasks that run on hosts other than the
suite host. If a remote host is specified cylc will attempt to execute
the task on that host by passwordless ssh. Cylc must be installed on 
remote task hosts, but of the external software dependencies only Pyro 
is required there (and actually not even that - see ``ssh messaging''
below). Passwordless ssh must be configured between the local suite
owner on the suite host, and the task owner on the remote task host.

\subparagraph[host]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ host}

The remote host for this task or family.

\begin{myitemize}
\item {\em type:} string (a valid hostname on the network)
\item {\em default:} (none)
\end{myitemize}

\subparagraph[owner]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ owner}

The task owner username. This is (only) used in the passwordless ssh
command line  invoked by cylc to submit the remote task (consequently it
may be defined using local environment variables 
(i.e.\ the shell in which cylc runs, and [cylc] $\rightarrow$ [[environment]]). 

\begin{myitemize}
\item {\em type:} string (a valid username on the remote host)
\item {\em default:} (none)
\end{myitemize}

\subparagraph[cylc directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ cylc directory}

The path to the remote cylc installation, required if cylc
is not in the default search path on the remote host.

\begin{myitemize}
\item {\em type:} string (a valid directory path on the remote host)
\item {\em default:} (none)
\end{myitemize}

\subparagraph[suite definition directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$  suite definition directory}

The path to the suite definition directory on the remote host, needed if
remote tasks require access to files stored there (via
\lstinline=$CYLC_SUITE_DEF_PATH=) or in the suite bin directory (via
\lstinline=$PATH=).  If this item is not defined, the local suite
definition directory path will be assumed, with the suite owner's home
directory, if present, replaced by \lstinline='$HOME'= for
interpretation on the remote host. 

\begin{myitemize}
\item {\em type:} string (a valid directory path on the remote host)
\item {\em default:} (local suite definition path with \lstinline=$HOME=
    replaced)
\end{myitemize}
 
\subparagraph[remote shell template]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ remote shell template }

A template for the remote shell command for a submitting a remote task.
The template's first \%s will be substituted by the remote user@host.

\begin{myitemize}
\item {\em type:} string (a string template)
\item {\em root default:} \lstinline@ssh -oBatchMode=yes %s@
\end{myitemize}

\subparagraph[log directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ log directory }

This log directory is used for the stdout and stderr logs of remote
tasks. The directory will be created on the fly if necessary. If not
specified, the local job submission log path will be used
(see~\ref{LocalLog}) with the
suite owner's home directory path, if present, replaced by
\lstinline='$HOME'= for interpretation on the remote host. The stdout
and stderr log file names are the same as for local tasks, and are
recorded by the task proxies for access via gcylc. Suite identity
variables can be used in the path, but {\em not task identity variables}
such as \lstinline=$CYLC_TASK_NAME= and \lstinline=$CYLC_TASK_CYCLE_TIME=, 
because the log directory is created before the task runs.

\begin{myitemize}
\item {\em type:} string (a valid directory path on the remote host)
\item {\em default:} (local log path with \lstinline=$HOME= replaced)
\end{myitemize}
 
\subparagraph[work directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ work directory}

Use this item if you need to override the local task work directory 
(see~\ref{LocalWork}). If omitted, the local directory will be used with
the suite owner's home directory path, if present,
replaced by \lstinline='$HOME'= for interpretation on 
the remote host.

\begin{myitemize}
\item {\em type:} string (directory path, may contain environment variables)
\item {\em default:} (local task work path with \lstinline=$HOME= replaced)
\end{myitemize}

\subparagraph[share directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ share directory}

Use this item if you need to override the local share directory 
(see~\ref{LocalShare}). If omitted, the local directory will be used
with the suite owner's home directory path, if present, replaced by
\lstinline='$HOME'= for interpretation on the remote host.

\begin{myitemize}
\item {\em type:} string (directory path, may contain environment variables)
\item {\em default:} (local task share path with \lstinline=$HOME= replaced)
\end{myitemize}

\subparagraph[ssh messaging]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ ssh messaging}

If your network configuration or firewall blocks the TCP/IP sockets
required for remote tasks to communicate with their parent suite
you can tell cylc to use passwordless ssh (from remote host to suite
host) instead, to invoke local messaging commands on the suite host.

\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} False
\end{myitemize}

This item affects the behaviour of the cylc messaging commands by means
of the task execution environment, so no special cylc configuration is
required on the remote host itself. Eventually it may be moved to a site
and host configuration file (yet to be implemented) because it is host-
rather than task-specific. For the moment though you can still set it
just once in a namespace inherited by all tasks on the affected host.

Note that you can use a remote section with this item in it even for
tasks that are local as far as cylc is concerned, but which end up
running on the affected remote host due to the action of the local batch
queueing system or resource manager.

\paragraph[{[[[}event hooks{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]]}
\label{TaskEventHandling}

Cylc can call a nominated ``event handler'' script when task events
such as failure or timeout occur. This is intended to facilitate
centralized alerting and automated handling of critical events. Event
handlers can send an email or an SMS, call a pager, and so on; or
intervene in the operation of their suite using cylc commands. The
command \lstinline=cylc [hook] email-task= is an example event handler
that comes with cylc.

Currently a single script can be nominated to handle a list of chosen
events, and the event name is passed to the handler to allow it to
distinguish between them (cylc once allowed distinct handlers for each
event but this required verbose configuration for little gain).

Custom task event handlers can be located in the suite bin directory.
They are passed the following arguments by cylc:

\begin{lstlisting}
<hook-script> EVENT SUITE TASKID MESSAGE
\end{lstlisting}
where EVENT is one of the following strings:
\begin{myitemize}
    \item `submitted' - the task was submitted
    \item `started' - the task started running 
    \item `succeeded' - the task succeeded
    \item `submission\_failed' - the task failed in job submission
    \item `warning' - the task reported a warning message
    \item `failed' - the task failed
    \item `retry' - the task failed but will retry
    \item `submission\_timeout' - task job submission timed out
    \item `execution\_timeout' - task execution timed out
\end{myitemize}
MESSAGE, if provided, describes what has happened, and TASKID identifies
the task (\lstinline=NAME%CYCLE= for cycling tasks).

To configure timeout handling put `submission\_timeout' and/or
`execution\_timeout' in the event list and specify corresponding timeout
values in minutes for the timeout items below.

{\em Note that event handlers are called by cylc itself, not by the 
running tasks} so if you wish to pass them additional information via
the environment you must use [cylc] $\rightarrow$ [[environment]],
not task runtime environments (suite-level variables -
\lstinline=$CYLC_SUITE_INITIAL_CYCLE_TIME=
etc.\ - are exported into the suite environment, however).

See also Section~\ref{SuiteEventHandling} for suite event hooks.

\subparagraph[events]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ events }

The list of events to handle, as documented for EVENT just above.
\begin{myitemize}
    \item {\em type:} list of strings
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[script]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ script}

The handler script to call when one of the nominated events occurs. To
test event handling try \lstinline=script = "echo !!!!"= and watch suite
stdout when nominated events occur.

\begin{myitemize}
    \item {\em type:} string
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[submission timeout]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ submission timeout}

If a task has not started the specified number of minutes after it was
submitted, the event handler will be called by cylc with 
{\em submission\_timeout} as the EVENT argument:
\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[execution timeout]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ execution timeout}

If a task has not finished the specified number of minutes after it
started running, the event handler will be called by cylc with {\em
execution\_timeout} as the EVENT argument:
\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[reset timer]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ reset timer}

If you set an execution timeout the timer can be reset to zero every
time a message is received from the running task (which indicates the 
task is still alive).  Otherwise, the task will timeout if it does not
finish in the alotted time regardless of incoming messages.

\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} False
\end{myitemize}

\paragraph[{[[[}environment{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment]]]}

The user defined task execution environment. Variables defined here can
refer to cylc suite and task identity variables, which are exported
earlier in the task job script, and variable assignment expressions can
use cylc utility commands because access to cylc is also configured
earlier in the script.  See also {\em Task Execution Environment},
Section~\ref{TaskExecutionEnvironment}.

\subparagraph[\_\_VARIABLE\_\_ ]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment]]] $\rightarrow$ \_\_VARIABLE\_\_}
\label{AppendixTaskExecutionEnvironment}

Replace \_\_VARIABLE\_\_ with any number of environment variable
assignment expressions.
Order of definition is preserved so values can refer to previously
defined variables. Values are passed through to the task job script
without evaluation or manipulation by cylc, so any variable assignment
expression that is legal in the job submission shell can be used. 
White space around the `$=$' is allowed (as far as cylc's suite.rc 
parser is concerned these are just normal configuration items).

\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\item {\em legal values:} depends to some extent on the task job
    submission shell (Section~\ref{JobSubShell}). 
\item {\em examples}, for the bash shell: 
   \begin{myitemize}
       \item \lstinline@FOO = $HOME/bar/baz@
       \item \lstinline@BAR = ${FOO}$GLOBALVAR@
       \item \lstinline@BAZ = $( echo "hello world" )@
       \item \lstinline@WAZ = ${FOO%.jpg}.png@
       \item \lstinline@NEXT_CYCLE = $( cylc cycletime -a 6 )@
       \item \lstinline@PREV_CYCLE = `cylc cycletime -s 6`@
       \item \lstinline@ZAZ = "${FOO#bar}" # <-- QUOTED to escape the suite.rc comment character@ 
   \end{myitemize}
\end{myitemize}

\paragraph[{[[[}directives{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[directives]]]}

Batch queue scheduler directives.  Whether or not these are used depends
on the job submission method. For the built-in loadleveler, pbs, and sge
methods directives are written to the top of the task job script in
the correct format for the method. Specifying directives individually
like this allows use of default directives that can be individually
overridden at lower levels of the runtime namespace hierarchy.

\subparagraph[\_\_DIRECTIVE\_\_ ]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[directives]]] $\rightarrow$ \_\_DIRECTIVE\_\_}

Replace \_\_DIRECTIVE\_\_ with each directive assignment, e.g. 
\lstinline@class = parallel@

\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\end{myitemize}

Example directives for the built-in job submission methods are shown in
Section~\ref{AvailableMethods}.

\paragraph[{[[[}outputs{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[outputs]]]}

This section is only required if other tasks need to trigger off specific
internal outputs of this task (as opposed to triggering off it finishing).
The task implementation must report the specified output messages 
by calling \lstinline=cylc task message= when the
corresponding real outputs have been completed.

\subparagraph[\_\_OUTPUT\_\_ ]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[outputs]]] $\rightarrow$ \_\_OUTPUT\_\_}

Replace \_\_OUTPUT\_\_ with any number of labelled output messages. 
\begin{myitemize}
    \item {\em type:} string (a message containing
        \lstinline=<CYLC_TASK_CYCLE_TIME>= with an optional offset as shown
        below. Note that you cannot use the corresponding shell variable
        \lstinline=$CYLC_TASK_CYCLE_TIME= here. The string substitution
        (replacing this special variable with the actual task cycle time) is
        done inside cylc, not in the task execution environment.
\item {\em default:} (none)
\item{ \em examples:}
 \begin{lstlisting}
 foo = "sea state products ready for <CYLC_TASK_CYCLE_TIME>"
 bar = "nwp restart files ready for <CYLC_TASK_CYCLE_TIME+6>"
 \end{lstlisting}
 where the item name must match the output label associated with
 this task in the suite dependency graph, e.g.:
\lstset{language=suiterc}
\begin{lstlisting}
[scheduling]
    [dependencies]
        graph = TaskA:foo => TaskB
 \end{lstlisting}
\end{myitemize}
\lstset{language=transcript}

\subsection{[visualization]}

Configuration of suite graphing and, where explicitly stated, the
graph-based suite control GUI.

\subsubsection[initial cycle time]{[visualization] $\rightarrow$ initial cycle time}

The first cycle time to use when plotting the suite dependency graph.
\begin{myitemize}
    \item {\em type:} integer
    \item {\em default:} 2999010100
\end{myitemize}

\subsubsection[final cycle time]{[visualization] $\rightarrow$ final cycle time}

The last cycle time to use when plotting the suite dependency graph.
Typically this should be just far enough ahead of the initial cycle to
show the full suite.

\begin{myitemize}
    \item {\em type:} integer
    \item {\em default:} 2999010123
\end{myitemize}

\subsubsection[collapsed families]{[visualization] $\rightarrow$ collapsed families}

A list of family (namespace) names to be shown in the collapsed state
(i.e.\ the family members will be replaced by a single family node) when
the suite is plotted in the graph viewer or the graph-based suite
control GUI. This item determines how family groups are shown 
{\em initially} in the suite control GUI; subsequently you can use the
interactive controls to group and ungroup nodes at will. For the same
reason (presence of interactive grouping controls) this item is ignored
if the suite is reparsed during graph viewing (other changes to graph
styling will be picked up and applied if the graph viewer detects that
the suite.rc file has changed). 

\begin{myitemize}
    \item {\em type:} list of family names
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[use node color for edges]{[visualization] $\rightarrow$ use node color for edges}

Graph edges (dependency arrows) can be plotted in the same color
as the upstream node (task or family) to make paths through a complex
graph easier to follow.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} True
\end{myitemize}

\subsubsection[use node color for labels]{[visualization] $\rightarrow$ use node color for labels}

Graph node labels can be printed in the same color as the node outline.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}


\subsubsection[default node attributes]{[visualization] $\rightarrow$ default node attributes}

Set the default attributes (color and style etc.) of graph nodes (tasks and families).
Attribute pairs must be quoted to hide the internal \lstinline@=@ character.

\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} \lstinline@'style=unfilled', 'color=black', 'shape=box'@
\end{myitemize}

\subsubsection[default edge attributes]{[visualization] $\rightarrow$ default edge attributes}

Set the default attributes (color and style etc.) of graph edges
(dependency arrows).  Attribute pairs must be quoted to hide the
internal \lstinline@=@ character.
\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} \lstinline@'color=black'@
\end{myitemize}

\subsubsection[enable live graph movie]{[visualization] $\rightarrow$ enable live graph movie}

If True, the graph-based suite control GUI will write out a dot-language
graph file on every change; these can be post-processed into a movie
showing how the suite evolves. The frames will be written to the run
time graph directory (see below).

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} \lstinline@False@
\end{myitemize}

\subsubsection[{[[}node groups{]]}]{[visualization] $\rightarrow$ [[node groups]]}

Define named groups of graph nodes (tasks and families) which can styled
en masse, by name, in [visualization] $\rightarrow$ [[node attributes]].
Node groups are automatically defined for all task families, including
root, so you can style family and member nodes at once by family name.

\paragraph[\_\_GROUP\_\_]{[visualization] $\rightarrow$ [[node groups]] $\rightarrow$ \_\_GROUP\_\_}

Replace \_\_GROUP\_\_ with each named group of tasks or families.

\begin{myitemize}
    \item {\em type:} comma separated list of task or family names
    \item {\em default:} (none)
    \item {\em example:}
\begin{lstlisting}
   PreProc = foo, bar
   PostProc = baz, waz
\end{lstlisting}
\end{myitemize}

\subsubsection[{[[}node attributes{]]}]{[visualization] $\rightarrow$ [[node attributes]]}

Here you can assign graph node attributes to specific nodes, or to all
members of named groups defined in [visualization] $\rightarrow$ [[node
groups]] (task families are automatically node groups). Group styling 
can be overridden for individual nodes or subgroups.

\paragraph[\_\_NAME\_\_]{[visualization] $\rightarrow$ [[node attributes]] $\rightarrow$ \_\_NAME\_\_}

Replace \_\_NAME\_\_ with each node or node group for style attribute
assignment.

\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} (none)
    \item {\em example:} (with reference to the node groups defined above)
\begin{lstlisting}
   PreProc = 'style=filled', 'color=blue'
   PostProc = 'color=red'
   foo = 'style=unfilled'
\end{lstlisting}
\end{myitemize}

\subsubsection[{[[}run time graph{]]}]{[visualization] $\rightarrow$ [[run time graph]]}

Cylc can generate graphs of dependencies resolved at run time, i.e.\ what 
actually triggers off what as the suite runs. This feature is retained
mainly for development and debugging purposes. You can use simulation
mode to generate run time graphs very quickly.

\paragraph[enable]{[visualization] $\rightarrow$ [[run time graph]] $\rightarrow$ enable}

Run time graphing is now disabled by default.
\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[cutoff]{[visualization] $\rightarrow$ [[run time graph]] $\rightarrow$ cutoff}

New nodes will be added to the run time graph as the corresponding tasks
trigger, until their cycle time exceeds the initial cycle time by more
than this cutoff, in hours.

\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, hours)
    \item {\em default:} $24$
\end{myitemize}

\paragraph[directory]{[visualization] $\rightarrow$ [[run time graph]] $\rightarrow$ directory}

Where to put the run time graph file, \lstinline=runtime-graph.dot=.

\begin{myitemize}
    \item {\em type:} string (a valid directory path, may contain environment variables)
    \item {\em default:} \lstinline=$CYLC_SUITE_DEF_PATH/graphing=
\end{myitemize}

% HIDDEN \subsection{[development]}
% HIDDEN \subsubsection[use quick task elimination]{[development] $\rightarrow$ use quick task elimination }
% HIDDEN     default True

\subsection{Special Placeholder Variables}

A small number of special variables are used as placeholders in cylc suite definitions:

\begin{myitemize}
    \item \lstinline=<CYLC_TASK_CYCLE_TIME>= and
        \lstinline=<CYLC_TASK_CYCLE_TIME+/-offset>= \newline
        These are replaced with the actual cycle time of the task (with
        optional computed offset) in the message strings registered for
        explicit internal (pre-completion) task outputs. They correspond to 
        \lstinline=$CYLC_TASK_CYCLE_TIME= in the task execution environment.

    \item \lstinline=<TASK>= and \lstinline=<NAMESPACE>= \newline
        These placeholder variables are replaced with actual task or
        namespace names in runtime settings. The difference between 
        the two is explained in Section~\ref{MultiTaskDef}, 
        {\em Defining Multiple Namespaces At Once}.

    \item \lstinline=<ASYNCID>=\newline
        This placeholder variable is replaced with the actual ``asynchronous
        ID'' (e.g. satellite pass ID) for repeating asynchronous tasks.
\end{myitemize}

To use real (programming language) variables in suite definitions, use the 
Jinja2 template processor (Section~\ref{Jinja2}).


\subsection{Default Suite Configuration}
\label{SuiteDefaults}

Cylc provides, via the suite.rc spec file, sensible default values for
many configuration items so that users may not need to explicitly
configure log directories and the like. The defaults are sufficient, in
fact, to define simple test suites by dependency graph alone
(command scripting, for example, defaults to printing a
simple message, sleeping for ten seconds, and then exiting). The
following listing shows all current legal items and any default values:

\lstset{language=suiterc}
\lstinputlisting{../conf/suiterc.defaults}
\lstset{language=transcript}
