\section{Suite.rc Reference}
\label{SuiteRCReference}

\lstset{language=bash}

This appendix documents legal content of raw cylc suite.rc files.
Many items have sensible default values, and most suites may only need to
explicitly configure a few of them.

In addition to the configuration items described below, Jinja2 expressions can
also be embedded to programmatically generate the final suite definition seen
by cylc.  Use of Jinja2 is documented in Section~\ref{Jinja2}.

See also {\em Suite Definition - Suite.rc Overview}
(Section~\ref{SuiteRCFile}) for a descriptive overview of suite.rc
files.

\subsection{Top Level Items}

The only top level configuration items at present are the suite title
and description.

\subsubsection{title}

A single line description of the suite. It is displayed in the db viewer 
window and can be retrieved at run time with the
\lstinline=cylc show= command.

\begin{myitemize}
\item {\em type:} single line string
\item {\em default:} ``No title provided''
\end{myitemize}

\subsubsection{description}

A multi-line description of the suite. It can be retrieved by the db viewer 
right-click menu, or at run time with the \lstinline=cylc show= command.

\begin{myitemize}
\item {\em type:} multi-line string
\item {\em default:} ``No description provided''
\end{myitemize}

\subsection{[cylc]}

This section is for suite configuration that is not specifically
task-related.

\subsubsection[required run mode]{ [cylc] $\rightarrow$ required run mode}

If this item is set cylc will abort if the suite is not started in the
specified mode. This can be used for demo suites that have to be
run in simulation mode, for example, because they have been taken out of
their normal operational context; or to prevent accidental submission of
expensive real tasks during suite development. 
\begin{myitemize}
    \item {\em type:} string
    \item {\em legal values:} live, dummy, simulation 
    \item {\em default:} None 
\end{myitemize}

\subsubsection[UTC mode]{ [cylc] $\rightarrow$ UTC mode}

Cylc runs off the suite host's system clock by default. This item allows
you to run the suite in UTC even if the system clock is set to local time.
Clock-triggered tasks will trigger when the current UTC time is equal to
their cycle time plus offset; other time values used, reported, or
logged by cylc will also be in UTC. 

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False 
\end{myitemize}


\subsubsection[abort if any task fails]{[cylc] $\rightarrow$ abort if any task fails}

Cylc does not normally abort if tasks fail, but if this item is turned
on it will abort with exit status 1 if any task fails.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[log resolved dependencies]{[cylc] $\rightarrow$ log resolved dependencies}

If this is turned on cylc will write the resolved dependencies of each
task to the suite log as it becomes ready to run (a list of the IDs of
the tasks that actually satisfied its prerequisites at run time). Mainly
used for cylc testing and development.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[job submission]{[cylc] $\rightarrow$ job submission}

Tasks ready to submit are now queued for processing in a background
worker thread, so submitting a lot of tasks at once does not hold cylc 
back.  In the job submission thread tasks are are batched, with members
of each batch being submitted in parallel. Batches are processed serially, 
with a delay between batches, to avoid swamping the host system with too
many simultaneous job submissions. 

The time required for a single task's job submission to complete
typically depends on whether it is a remote task (for which an ssh
connection must be established and used) and whether dynamic host
selection is used (see~\ref{DynamicHostSelection} (a dynamic host
selection command runs as part of the job submission command). The time
taken for a batch of parallel job submissions to complete will be
roughly the duration of the slowest member process. 

\paragraph[batch size]{[cylc] $\rightarrow$ [job submission] $\rightarrow$ batch size}

The maximum number of tasks to be submitted in a single batch, in the
job submission thread. Cylc waits for all batch member job-submissions
to complete before proceeding to the next batch.

\begin{myitemize}
    \item {\em type:} integer (minimum 1)
    \item {\em default:} 10
\end{myitemize}

\paragraph[delay between batches]{[cylc] $\rightarrow$ [job submission] $\rightarrow$ delay between batches}

It may cause a problem for some batch queue schedulers to submit too
many jobs at once, so cylc allows a configurable delay between job 
submission batches.

\begin{myitemize}
    \item {\em type:} integer seconds (minimum 0)
    \item {\em default:} 15
\end{myitemize}

\subsubsection[event handler execution]{[cylc] $\rightarrow$ [event handler execution]}

Task event handlers are queued to a background worker thread that limits
the number of event handlers that can run at once, as for task job
submissions (above), because of the potential for large suites to swamp
the suite host with event handlers. Event handlers are currently
executed directly as sub-processes (i.e.\ unlike task job submission you
can't specify the ``job submission method'' to use).

Note that {\em suite} event handlers are currently executed directly in
the main scheduler thread, not queued to the task event handler worker
thread.

\paragraph[batch size]{[cylc] $\rightarrow$ [event handler execution] $\rightarrow$ batch size}

The maximum number of event handlers to be executed in parallel in the
worker thread. Cylc waits for all batch members to complete before
proceeding on to the next batch.

\begin{myitemize}
    \item {\em type:} integer (minimum 1)
    \item {\em default:} 5
\end{myitemize}

\paragraph[delay between batches]{[cylc] $\rightarrow$ [event handler execution] $\rightarrow$ delay between batches}

A configurable delay between batches of task event handlers.

\begin{myitemize}
    \item {\em type:} integer seconds (minimum 0)
    \item {\em default:} 0
\end{myitemize}

\subsubsection[{[[}event hooks{]]}]{[cylc] $\rightarrow$ [[event hooks]]}
\label{SuiteEventHandling}

Cylc has internal ``hooks'' to which you can attach handlers that are 
called whenever certain events occur. This section is for configuring suite
event hooks. See Section~\ref{TaskEventHandling} for task event hooks.

Event handlers can send an email or an SMS, call a pager, and so on; or
intervene in the operation of their own suite using cylc commands. 
The command \lstinline=cylc [hook] email-suite= is a ready-made suite
event handler.

Custom suite event handlers can be located in the suite bin directory,  
in which case you will not need to modify your \lstinline=$PATH= to ensure
they are found.  They are called by cylc with the following arguments:
\begin{lstlisting}
<handler> EVENT SUITE MESSAGE
\end{lstlisting}
EVENT is the event name (see below), SUITE is the suite name, and 
MESSAGE, if provided, describes what has happened.

{\em Note that event handlers are called by cylc itself} so if you wish
to pass additional information to them via the environment you must use
[cylc] $\rightarrow$ [[environment]], not task runtime environments
(suite-level variables - \lstinline=$CYLC_SUITE_INITIAL_CYCLE_TIME=
etc.\ - are exported into the cylc environment, however).

\paragraph[EVENT handler]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ EVENT handler}

The handler to call when the suite event EVENT occurs. Repeat this
section for each of the following suite events that you wish to handle:
\begin{myitemize}
    \item `startup' - the suite started running 
    \item `shutdown' - the suite stopped, normally or not
    \item `timeout' - the suite timed out
\end{myitemize}

\begin{myitemize}
    \item {\em type:} string (the event handler)
    \item {\em default:} None
    \item {\em example:} \lstinline@startup handler = my-handler.sh@
\end{myitemize}

\paragraph[timeout]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ timeout}

If a timeout is set and the timeout event is handled, the event
handler will be called if the suite times out before it finishes.
The timer is set initially at suite start up. 

\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} (none)
\end{myitemize}

\paragraph[reset timer]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ reset timer}

If \lstinline=True= (the default) the suite timer will continually reset
after any task changes state, so you can time out after some interval
since the last activity occured rather than on absolute suite execution
time.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} True
\end{myitemize}

\paragraph[abort on timeout]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ abort on timeout}

If a suite timer is set (above) this will cause the suite to abort with
error status if the suite times out while still running.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[abort if startup handler fails]{[cylc] $\rightarrow$ [[event hooks]] $\rightarrow$ abort if EVENT handler fails}

Cylc does not normally care whether an event handler succeeds or fails,
but if this is turned on the EVENT handler will be executed in the
foreground (which will block the suite while it is running) and the
suite will abort if the handler fails.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[{[[}lockserver{]]}]{[cylc] $\rightarrow$ [[lockserver]]}

The cylc lockserver brokers suite and task locks on the network (these
are somewhat analagous to traditional local {\em lock files}). It
prevents multiple instances of a suite or task from being invoked 
at the same time (via scheduler instances or \lstinline=cylc submit=).
 
See \lstinline=cylc lockserver --help= for 
how to run the lockserver, and \lstinline=cylc lockclient --help= for 
occasional manual lock management requirements. 

\paragraph[enable]{[cylc] $\rightarrow$ [[lockserver]] $\rightarrow$ enable}

The lockserver is currently disabled by default. It is intended mainly for
operational use.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[simultaneous instances]{[cylc] $\rightarrow$ [[lockserver]] $\rightarrow$ simultaneous instances}

By default the lockserver prevents multiple simultaneous instances of a
suite from running even under different registered names. But allowing
this may be desirable if the I/O paths of every task in the suite are
dynamically configured to be suite specific (and similarly for the suite
state dump and logging directories, by using suite identity variables in
their directory paths). Note that {\em the lockserver cannot protect you
from running multiple distinct {\bf copies} of a suite simultaneously}. 

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[{[[}environment{]]} ]{[cylc] $\rightarrow$ [[environment]]}

Variables defined here are exported into the environment in which cylc
itself runs. They are then available to {\em local processes spawned
directly by cylc}. Any variables read by task event handlers must be
defined here, for instance, because event handlers are executed
directly by cylc, not by running tasks. And similarly the {command
lines} issued by cylc to invoke event handlers or to submit task 
job scripts could, in principle, make use of environment variables
defined here. 
\paragraph{Warnings}

\begin{myitemize}
    \item Cylc local variables are not available to
        executing tasks unless you happen to choose a local direct job
        submission method.  {\em Always use task runtime environments to
        pass variables into the task execution environment
        (\ref{AppendixTaskExecutionEnvironment}).}
    \item Unlike task execution environment variables, which are written
        to job scripts and interpreted by the shell at run time, 
        cylc local environment variables are written directly 
        to the environment by Python as literal strings {\em  so 
        shell variable expansion expressions cannot be used here.}
\end{myitemize}

\paragraph[\_\_VARIABLE\_\_ ]{[cylc] $\rightarrow$ [[environment]] $\rightarrow$ \_\_VARIABLE\_\_}

Replace \_\_VARIABLE\_\_ with any number of environment variable
assignment expressions.
Values may refer to other local environment variables (order of
definition is preserved) and are not evaluated or manipulated by 
cylc, so any variable assignment expression that is legal in the 
shell in which cylc is running can be used (but see the warning 
above on variable expansions, which will not be evaluated).
White space around the `$=$' is allowed (as far as cylc's suite.rc 
parser is concerned these are normal configuration items).

\begin{myitemize}
    \item {\em type:} string
    \item {\em default:} (none)
    \item {\em examples:} 
        \begin{myitemize}
            \item \lstinline@FOO = $HOME/foo@
        \end{myitemize}
\end{myitemize}

\subsubsection[{[[}accelerated clock{]]}]{[cylc] $\rightarrow$ [[accelerated clock]] }
\label{ClockConfig}

Accelerated clock settings, used to speed up the wait between cycles in
the simulation and dummy run modes. 

\paragraph[disable]{[cylc] $\rightarrow$ [[accelerated clock]] $\rightarrow$ disable}

Disabling the accelerated clock makes the suite (and its log time stamps
etc.) run on real time. Note that if the suite has clock-triggered tasks
that catch up to the wall clock, the interval between cycles will also be
in real time - e.g.\ six hours for a six hourly cycle.

\begin{myitemize}
    \item {\em type:} boolean 
    \item {\em default:} False
\end{myitemize}


\paragraph[rate]{[cylc] $\rightarrow$ [[accelerated clock]] $\rightarrow$ rate}

The rate at which the accelerated clock runs in real seconds per
simulated hour.

\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, real seconds per simulated hour)
    \item {\em default:} $10$
\end{myitemize}

\paragraph[offset]{[cylc] $\rightarrow$ [[accelerated clock]] $\rightarrow$ offset}

The clock offset determines the initial time on the accelerated clock, 
at suite startup, relative to the initial cycle time. An offset of
$0$ simulates real time operation; greater offsets simulate catch up
from a delay and subsequent transition to real time operation.

\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, hours behind initial cycle time)
    \item {\em default:} $24$
\end{myitemize}


\subsubsection[{[[}reference test{]]}]{[cylc] $\rightarrow$ [[reference test]] }
\label{ReferenceTestConfig}

Reference tests are finite-duration suite runs that abort with non-zero
exit status if cylc fails, if any task fails, if the suite times
out, or if a shutdown event handler that (by default) compares the test
run with a reference run reports failure. See {\em Automated Reference Test
Suites}, Section~\ref{AutoRefTests}.

\paragraph[suite shutdown event handler]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ suite shutdown event handler}

A shutdown event handler that should compare the test run with the
reference run, exiting with zero exit status only if the test run
verifies.

\begin{myitemize}
    \item {\em type:} string (event handler command name or path)
    \item {\em default:} \lstinline=cylc hook check-triggering=
\end{myitemize}
As for any event handler, the full path can be ommited if the script is
located somewhere in \lstinline=$PATH= or in the suite bin directory.

\paragraph[required run mode]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ required run mode}

If your reference test is only valid for a particular run mode, this
setting will cause cylc to abort if a reference test is attempted 
in another run mode.

\begin{myitemize}
    \item {\em type:} string
    \item {\em legal values:} live, dummy, simulation
    \item {\em default:} None
\end{myitemize}

\paragraph[allow task failures]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ allow task failures}

A reference test run will abort immediately if any task fails, unless
this item is set, or a list of {\em expected task failures} is provided
(below).

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[expected task failures]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ expected task failures}

A reference test run will abort immediately if any task fails, unless
{\em allow task failures} is set (above) or the failed task is found 
in a list IDs of tasks that are expected to fail.

\begin{myitemize}
    \item {\em type:} list of strings (task IDs: \lstinline=name.tag=)
    \item {\em default:} (none)
    \item {\em example:} \lstinline=foo.20120808, bar.20120908=
\end{myitemize}

\paragraph[live mode suite timeout]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ live mode suite timeout}

The timeout value in minutes after which the test run should be aborted
if it has not finished, in live mode. Test runs cannot be done in live
mode unless you define a value for this item, because it is not possible
to arrive at a sensible default for all suites.

\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} None
\end{myitemize}

\paragraph[simulation mode suite timeout]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ simulation mode suite timeout}

The timeout value in minutes after which the test run should be aborted
if it has not finished, in simulation mode. Test runs cannot be done in
simulation mode unless you define a value for this item, because it is
not possible to arrive at a sensible default for all suites.

\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} None
\end{myitemize}

\paragraph[dummy mode suite timeout]{[cylc] $\rightarrow$ [[reference test]] $\rightarrow$ dummy mode suite timeout}

The timeout value in minutes after which the test run should be aborted
if it has not finished, in dummy mode.  Test runs cannot be done in
dummy mode unless you define a value for this item, because it is not
possible to arrive at a sensible default for all suites.

\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} None
\end{myitemize}


\subsection{[scheduling]}

This section allows cylc to determine when tasks are ready to run.

\subsubsection[initial cycle time]{[scheduling] $\rightarrow$ initial cycle time}

At startup each cycling task (unless specifically excluded under
[special tasks]) will be inserted into the suite with this cycle time,
or with the closest subsequent valid cycle time for the task. Note that
whether or not {\em cold-start tasks}, specified under [special tasks],
are inserted, and in what state they are inserted, depends on the start
up method - cold, warm, or raw.  If this item is provided you can 
override it on the command line or in the gcylc suite start panel.

\begin{myitemize}
    \item {\em type:} integer (YYYY[MM[DD[HH[mm[ss]]]]])
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[final cycle time]{[scheduling] $\rightarrow$ final cycle time}

Cycling tasks are held once they pass the final cycle time, if one is
specified. Once all tasks have achieved this state the suite will shut
down. If this item is provided you can override it on the command line
or in the gcylc suite start panel.

\begin{myitemize}
    \item {\em type:} integer (YYYY[MM[DD[HH[mm[ss]]]]])
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[runahead limit]{[scheduling] $\rightarrow$ runahead limit}

The suite runahead limit prevents the fastest tasks in a suite from
getting too far ahead of the slowest ones, as documented in
Section~\ref{RunaheadLimit}. Tasks exceeding the limit are put into
a special runahead held state until slower tasks have caught up
sufficiently. 
\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, hours)
    \item {\em default:} (twice the minimum cycling interval in the suite)
\end{myitemize}

\subsubsection[{[[}queues{]]}]{[scheduling] $\rightarrow$ [[queues]]}

Configuration of internal queues, by which the number of simultaneously
active tasks (submitted or running) can be limited, per queue. By
default a single queue called {\em default} is defined, with all tasks 
assigned to it and no limit. To use a single queue for the whole suite 
just set the limit on the {\em default} queue as required.
See also Section~\ref{InternalQueues}.

\paragraph[{[[[}\_\_QUEUE\_\_{]]]}]{[scheduling] $\rightarrow$ [[queues]] $\rightarrow$ [[[\_\_QUEUE\_\_]]]}

Section heading for configuration of a single queue. Replace
\_\_QUEUE\_\_ with a queue name, and repeat the section as required.

\begin{myitemize}
\item {\em type:} string
\item {\em default:} ``default''
\end{myitemize}

\paragraph[limit]{[scheduling] $\rightarrow$ [[queues]] $\rightarrow$ [[[\_\_QUEUE\_\_]]] $\rightarrow$ limit}

The maximum number of active tasks allowed at any one time, for this queue.
\begin{myitemize}
\item {\em type:} integer
\item {\em default:} 0 (i.e.\ no limit)
\end{myitemize}

\paragraph[members]{[scheduling] $\rightarrow$ [[queues]] $\rightarrow$ [[[\_\_QUEUE\_\_]]] $\rightarrow$ members}

A list of member tasks, or task family names, to assign to this queue
(assigned tasks will automatically be removed from the default queue).
\begin{myitemize}
\item {\em type:} list of strings
\item {\em default:} none for user-defined queues; all tasks for the ``default'' queue
\end{myitemize}

\subsubsection[{[[}special tasks{]]}]{[scheduling] $\rightarrow$ [[special tasks]]}

This section identifies any tasks with special behaviour. By default
(i.e.\ non ``special'' behaviour) tasks submit (or queue) as soon as
their prerequisites are satisfied, and they spawn a successor at the
next valid cycle time for the task as soon as they enter the submitted 
state\footnote{Spawning any earlier than this brings no advantage in
terms of functional parallelism and would cause uncontrolled
proliferation of waiting tasks.}

\paragraph[clock-triggered]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ clock-triggered}

Clock-triggered tasks wait on a wall clock time specified as an offset
{\em in hours} relative to their own cycle time, in addition to any
dependence they have on other tasks. Generally speaking, only tasks that
wait on external real time data need to be clock-triggered.  Note that
in computing the trigger time the full wall clock time and cycle time
are compared, not just hours and minutes of the day, so when running a
suite in catchup/delayed operation, or over historical periods,
clock-triggered tasks will not constrain the suite at all until they
catch up to the wall clock.

\begin{myitemize}
    \item {\em type:} list of tasknames with offsets (hours, positive or negative)
    \item {\em default:} (none)
    \item {\em example:} \lstinline@clock-triggered = foo(1.5), bar(2.25)@
\end{myitemize}

\paragraph[start-up]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ start-up}

Start-up tasks are one-off tasks (they do not spawn a successor) that
only run in the first cycle (and only in a cold-start) and any
dependence on them is ignored in subsequent cycles. They can be used to
prepare a suite workspace, for example, before other tasks run. Start-up
tasks cannot appear in conditional trigger expressions with normal
cycling tasks, because the meaning of the conditional expression becomes
undefined in subsequent cycles. 

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[cold-start]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ cold-start}

A cold-start task is one-off task used to satisfy the dependence of an
associated task with the same cycle time, on outputs from a previous
cycle - when those outputs are not available.  The primary use for this
is to cold-start a warm-cycled forecast model that normally depends on
restart files (e.g.\ model background fields) generated by its previous
forecast, when there is no previous forecast.  This is required when
cold-starting the suite, but cold-start tasks can also be inserted into
a running suite to restart a model that has had to skip some cycles
after running into problems. Cold-start tasks can invoke real cold-start
processes, or they can just be dummy tasks that represent some external
process that has to be completed before the suite is started. Unlike
{\em start-up} tasks, dependence on cold-start tasks is preseverved in
subsequent cycles so they must typically be used in OR'd conditional
expressions to avoid holding up the suite.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[sequential]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ sequential}

By default, a task spawns a successor as soon as it is submitted to run
so that successive instances of the same task can run in parallel if the
opportunity arises (i.e.\ if their prerequisites happen to be satisfied
before their predecessor has finished). {\em Sequential tasks}, however,
will not spawn a successor until they have finished successfully. This
should be used for (a) {\em tasks that cannot run in parallel with their
own previous instances} because they would somehow interfere with each
other (use cycle time in all I/O paths to avoid this); and (b) {\em warm
cycled forecast models that write out restart files for multiple cycles
ahead} (exception: see ``explicit restart outputs''
below).\footnote{This is because you don't want Model[T] waiting around
to trigger off Model[T-12] if Model[T-6] has not finished yet. If Model
is forced to be sequential this can't happen because Model[T] won't
exist in the suite until Model[T-6] has finished. But if Model[T-6]
fails, it can be spawned-and-removed from the suite so that Model[T] can
{\em then} trigger off Model[T-12], which is the correct behaviour.} 

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[one-off]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ one-off}

Synchronous one-off tasks have an associated cycle time but do not spawn
a successor. Synchronous {\em start-up} and {\em cold-start} tasks are
automatically one-off tasks and do not need to be listed here.
Dependence on one-off tasks is not restricted to the first cycle.

\begin{myitemize}
\item {\em type:} list of task names
\item {\em default:} (none)
\end{myitemize}

\paragraph[explicit restart outputs]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ explicit restart outputs}

% TO DO: THESE TASKS COULD BE IDENTIFIED FROM THE GRAPH?

This is only required in the event that you need a warm cycled forecast
model to start at the instant its restart files are ready (if other
prerequisites are satisfied) {\em even if its previous instance has
not finished yet}.  If so, the model task has to depend on special
output messages emitted by the previous instance as soon as its restart
files are ready, instead of just on the previous instance finishing.
{\em Tasks in this category must define special restart
output messages containing the word ``restart''}, in
[runtime] $\rightarrow$ [[TASK]] $\rightarrow$ [[[outputs]]] - see
Section~\ref{RIOC}.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[exclude at start-up]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ exclude at start-up}
\label{EASU}

Any task listed here will be excluded from the initial task pool (this
goes for suite restarts too). If an {\em inclusion} list is also
specified, the initial pool will contain only included tasks that have
not been excluded. Excluded tasks can still be inserted at run time.
Other tasks may still depend on excluded tasks if they have not been
removed from the suite dependency graph, in which case some manual
triggering, or insertion of excluded tasks, may be required.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[include at start-up]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ include at start-up}
\label{IASU}

If this list is not empty, any task {\em not} listed in it will be
excluded from the initial task pool (this goes for suite restarts too).
If an {\em exclusion} list is also specified, the initial pool will
contain only included tasks that have not been excluded. Excluded tasks
can still be inserted at run time. Other tasks may still depend on
excluded tasks if they have not been removed from the suite dependency
graph, in which case some manual triggering, or insertion of excluded 
tasks, may be required.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[{[[}dependencies{]]}]{[scheduling] $\rightarrow$ [[dependencies]]}

The suite dependency graph is defined under this section.  You can plot
the dependency graph as you work on it, with \lstinline=cylc graph= or
by right clicking on the suite in the db viewer.  See also 
Section~\ref{ConfiguringScheduling}.

\paragraph[graph]{ [scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ graph }

The dependency graph for any one-off asynchronous (non-cycling) tasks in
the suite goes here. This can be used to construct a suite of one-off
tasks (e.g.\ build jobs and related processing) that just completes and
then exits, or an initial suite section that completes prior to the
cycling tasks starting (if you make the first cycling tasks depend on
the last one-off ones). But note that synchronous {\em start-up} tasks
can also be used for the latter purpose.  See Section~\ref{GraphDescrip}
below for graph string syntax, and Section~\ref{ConfiguringScheduling}.
\begin{myitemize}
    \item {\em type:} string 
    \item {\em example:} (see Section~\ref{GraphDescrip} below)
\end{myitemize}
 
\paragraph[{[[[}\_\_VALIDITY\_\_{]]]}]{[scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ [[[\_\_VALIDITY\_\_]]]}

\_\_VALIDITY\_\_ section headings define the sequence of cycle times for
which the subsequent graph section is valid. For cycling tasks use a
comma-separated list of integer hours, $0\leq H \leq 23$ for the original 
hours-of-the-day cycling, or reference a particular stepped daily,
monthly, or yearly cycling module:
\begin{myitemize}
    \item {\em examples:} 
        \begin{myitemize} 
            \item hours-of-the-day cycling: \lstinline@[[[0,6,12,18]]]@ or \lstinline@[[[HoursOfTheDay(0,6,12,18)]]]@ 
            \item stepped daily cycling: \lstinline@[[[Daily(20100823,2)]]]@ 
            \item stepped monthly cycling: \lstinline@[[[Monthly(201008,2)]]]@ 
            \item stepped yearly cycling: \lstinline@[[[Yearly(2010,2)]]]@ 
        \end{myitemize}
    \item {\em default:} (none)
\end{myitemize}
For repeating asynchronous tasks put `ASYNCID:{\em pattern}' in the
section heading, where {\em pattern} is a regular expression that
matches an asynchronous task ID:
\begin{myitemize}
    \item {\em examples:} 
        \begin{myitemize} 
            \item repeating asynchronous tasks: \lstinline@[[ASYNCID:SAT-\d+]]@ 
        \end{myitemize}
    \item {\em default:} (none)
\end{myitemize}

See Section~\ref{GraphTypes}, {\em Graph Types} for the meaning of the
stepped cycler arguments, how multiple graph sections combine within a
single suite, and so on.

\subparagraph[graph]{[scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ [[[\_\_VALIDITY\_\_]]] $\rightarrow$ graph }
\label{GraphDescrip}

The dependency graph for the specified validity section (described just
above) goes here. Syntax examples follow; see also
Sections~\ref{ConfiguringScheduling} ({\em Configuring Scheduling})
and~\ref{TriggerTypes} ({\em Trigger Types}). 

\begin{myitemize}
\item {\em type:} string 
\item {\em examples:}
  \begin{lstlisting}
graph = """
   foo => bar => baz & waz   # baz and waz both trigger off bar
   baz:out1 => faz           # faz triggers off an internal output of baz
   ColdFoo | foo[T-6] => foo # cold-start or restart for foo
   X:start => Y              # Y triggers if X starts executing
   X:fail => Y               # Y triggers if X fails
   foo[T-6]:fail => bar      # bar triggers if foo[T-6] fails
   X => !Y                   # Y suicides if X succeeds
   X | X:fail => Z           # Z triggers if X succeeds or fails
   X:finish => Z             # Z triggers if X succeeds or fails
   (A | B & C ) | D => foo   # general conditional triggers
   # comment
   """
  \end{lstlisting}
\item {\em default:} (none)
\end{myitemize}

\subparagraph[daemon]{[scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ [[[\_\_VALIDITY\_\_]]] $\rightarrow$ daemon }

For [[[ASYNCID:pattern]]] validity sections only, list 
{\em asynchronous daemon} tasks by name. This item is located here rather than
under [scheduling] $\rightarrow$ [[special tasks]] because a damon task
is associated with a particular asynchronous ID.

\begin{myitemize}
\item {\em type:} list of task names
\item {\em default:} (none)
\end{myitemize}

\subsection{[runtime]}

This section is used to specify how, where, and what to execute when
tasks are ready to run. Common
configuration can be factored out in a multiple-inheritance hierarchy of
runtime namespaces that culminates in the tasks of the suite. Order of
precedence is determined by the C3 linearization algorithm as used to
find the {\em method resolution order} in Python language class
hiearchies. For details and examples see Section~\ref{NIORP}, {\em
Runtime Properties}.

\subsubsection[{[[}\_\_NAME\_\_{]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]]}

Replace \_\_NAME\_\_ with a namespace name, or a comma separated list of
names, and repeat as needed to define all tasks in the suite. Names may
contain letters, digits, underscores, and hyphens. A namespace
represents a group or family of tasks if other namespaces inherit from
it, or a task if no others inherit from it.

%Names may not contain colons (which would preclude use of directory paths
%involving the registration name in \lstinline=$PATH= variables). They 
%may not contain the `.' character (it will be interpreted as the
%namespace hierarchy delimiter, separating groups and names -huh?). 

\begin{myitemize}
\item {\em legal values:} 
    \begin{myitemize}
        \item \lstinline=[[foo]]=
        \item \lstinline=[[foo, bar, baz]]=
    \end{myitemize}
\end{myitemize}

If multiple names are listed the subsequent settings apply to each. 

All namespaces inherit initially from {\em root}, which can be
explicitly configured to provide or override default settings
for all tasks in the suite.

\paragraph[inherit]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ inherit}

A list of the immediate parent(s) this namespace inherits from. If no
parents are listed \lstinline=root= is assumed.

\begin{myitemize}
\item {\em type:} comma-separated list of strings (other namespace names)
\item {\em default:} \lstinline=root=
\end{myitemize}

\paragraph[title]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ title}

A single line description of this namespace. It is displayed by the
\lstinline=cylc list= command and can be retrieved from running tasks
with the \lstinline=cylc show= command.

\begin{myitemize}
\item {\em type:} single line string 
\item {\em root default:} ``No title provided''
\end{myitemize}

\paragraph[description]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ description}

A multi-line description of this namespace, retrievable from running tasks with the 
\lstinline=cylc show= command.

\begin{myitemize}
\item {\em type:} multi-line string 
\item {\em root default:} ``No description provided''
\end{myitemize}


\paragraph[initial scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ initial scripting}

Initial scripting is executed at the top of the task job script just
before the \lstinline=cylc task started= message call is made, and
before the task execution environment is configured - so it does not
have access to any suite or task environment variables.  The original
intention was to allow remote tasks to source login scripts before
calling the first cylc command, e.g.\ to set \lstinline=$PYTHONPATH= if
Pyro has been installed locally. Note however that the remote task
invocation mechanism now automatically sources both
\lstinline=/etc/profile= and \lstinline=$HOME/.profile= if they exist. 
For other uses pre-command scripting should be used if possible because
it can has access to the task execution environment.
\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\item {\em example:} \lstinline@initial scripting = "echo Hello World"@
\end{myitemize}

\paragraph[environment scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ environment scripting}

Environment scripting is inserted into the task job script between
the cylc-defined environment (suite and task identity, etc.) and the 
user-defined task runtime environment - i.e.\ it has access to the 
cylc environment, and the task environment has access to the results of
this scripting.
\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\item {\em example:} \lstinline@environment scripting = "echo Hello World"@
\end{myitemize}

\paragraph[command scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ command scripting}

The scripting to execute when the associated task is ready to run - this
can be a single command or multiple lines of scripting. 

\begin{myitemize}
\item {\em type:} string
\item {\em root default:} \lstinline=echo "Default command scripting"; sleep 10=
\end{myitemize}


\paragraph[retry delays]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ retry delays}
\label{RefRetries}

A list of time intervals in minutes, after which to resubmit the task if
it reports failure. The variable \lstinline=$CYLC_TASK_TRY_NUMBER= in
the task execution environment is incremented each time, starting from 1
for the original try; this can be used to vary task behavior according
to the try number. 

\begin{myitemize}
\item {\em type:} list of floats, optional preceded by multipliers
\item {\em example:} \lstinline=1.5,3*10= is equivalent to \lstinline=1.5,10,10,10=
\item {\em root default:} (none)
\end{myitemize}

\paragraph[pre-command scripting]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ pre-command scripting}

Scripting to be executed immediately {\em before} the command scripting.
This would typically be used to add scripting to every task in a family
(for individual tasks you could just incorporate the extra commands into
the main command scripting). See also {\em post-command scripting},
below.

\begin{myitemize}
\item {\em type:} string, or a list of strings
\item {\em default:} (none)
\item {\em example:} 
 \begin{lstlisting}
    pre-command scripting = """
      . $HOME/.profile
      echo Hello from suite ${CYLC_SUITE_REG_NAME}!"""
 \end{lstlisting}
\end{myitemize}

\paragraph[post-command scripting]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ post-command scripting}

Scripting to be executed immediately {\em after} the command scripting.
This would typically be used to add scripting to every task in a family
(for individual tasks you could just incorporate the extra commands into
the main command scripting). See also {\em pre-command scripting},
above.

\begin{myitemize}
\item {\em type:} string, or a list of strings
\item {\em default:} (none)
\end{myitemize}

\paragraph[manual completion]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ manual completion}

If a task's initiating process detaches and exits before task processing
is finished then cylc cannot arrange for the task to automatically
signal when it has succeeded or failed. In such cases you must use this 
configuration item to tell cylc not to arrange for automatic completion
messaging, and insert some minimal completion messaging yourself in
appropriate places in the task implementation (see
Section~\ref{DetachingTasks}).

\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} False
\end{myitemize}

% HIDDEN \paragraph[hours]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ hours}

% HIDDEN \paragraph[extra log files]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ extra log files}

\paragraph[enable resurrection]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ enable resurrection}

If a message is received from a failed task cylc will normally treat
this as an error condition, issue a warning, and leave the task in the
``failed'' state.  But if ``enable resurrection'' is switched on failed
tasks can come back from the dead: if the same task job script is
executed again cylc will put the task back into the running state and
continue as normal when the started message is received. This can be
used to handle HPC-style job preemption wherein a resource manager may
kill a running task and reschedule it to run again later, to make way
for a job with higher immediate priority. See also
Section~\ref{PreemptionHPC}, {\em Handling Job Preemption}
\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} False
\end{myitemize}

\paragraph[{[[[}dummy mode{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[dummy mode]]]}

Dummy mode configuration.

\subparagraph[command scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[dummy mode]]] $\rightarrow$ command scripting}

The scripting to execute when the associated task is ready to run, {\em
in dummy mode} - this can be a single command or a multiple lines of
scripting. 

\begin{myitemize}
\item {\em type:} string
\item {\em root default:} \lstinline=echo "Dummy command scripting"; sleep $(cylc rnd 1 16)=
\end{myitemize}

\subparagraph[disable pre-command scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[dummy mode]]] $\rightarrow$ disable pre-command scripting}

This disables pre-command scripting, is likely to contain code specific
to the real task, in dummy mode. 

\begin{myitemize}
\item {\em type:} boolean
\item {\em root default:} True
\end{myitemize}

\subparagraph[disable post-command scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[dummy mode]]] $\rightarrow$ disable post-command scripting}

This disables post-command scripting, which is likely to contain code
specific to the real task, in dummy mode. 

\begin{myitemize}
\item {\em type:} boolean
\item {\em root default:} True
\end{myitemize}

\paragraph[{[[[}simulation mode{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[simulation mode]]]}

Simulation mode configuration.

\begin{myitemize}
\item {\em type:} float
\item {\em root default:} $10$
\end{myitemize}

\paragraph[run time range]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[simulation mode]]] $\rightarrow$ run time range}

This defines an interval \lstinline=[min,max)= (seconds) from within
which the the simulation mode task run length will be randomly chosen.

\begin{myitemize}
\item {\em type:} integer list (two members)
\item {\em root default:} $1,16$
\end{myitemize}

\paragraph[{[[[}job submission{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]]}

This section configures the means by which cylc submits task job scripts to run.

\subparagraph[method]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ method}
\label{RuntimeJobSubMethods}

See {\em Task Job Submission} (Section~\ref{TaskJobSubmission}) 
for how job submission works, and how to define new methods.
Cylc has a number of built in job submission methods:
\begin{myitemize}
\item {\em type:} string
\item {\em legal values:} 
   \begin{myitemize}
       \item {\em background} - direct background execution
       \item {\em at} - the rudimentary Unix \lstinline=at= scheduler
       \item {\em loadleveler} - \lstinline=llsubmit=, with directives defined in the suite.rc file 
       \item {\em pbs} - PBS \lstinline=qsub=, with directives defined in the suite.rc file 
       \item {\em sge} - Sun Grid Engine \lstinline=qsub=, with directives defined in the suite.rc file 
   \end{myitemize}
\item {\em default:} \lstinline=background=
\end{myitemize}

\subparagraph[command template]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ command template}

This allows you to override the actual command used by the chosen job
submission method. The template's first \%s will be substituted by the
job file path.  Where applicable the second and third \%s will be
substituted by the paths to the job stdout and stderr files.

\begin{myitemize}
\item {\em type:} string
\item {\em legal values:} a string template
\item {\em example:} \lstinline@llsubmit %s@
\end{myitemize}

\subparagraph[shell]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ shell}
\label{JobSubShell}

This is the shell used to interpret the job script submitted by cylc
when a task is ready to run.  {\em It has no bearing on the shell used
in task implementations.} Command scripting and suite environment 
variable assignment expressions must be valid for this shell. The 
latter is currently hardwired into cylc as 
\lstinline@export item=value@ - valid for both bash and ksh
because \lstinline=value= is entirely user-defined - but cylc would have
to be modified slightly to allow use of the C shell.

\begin{myitemize}
\item {\em type:} string
\item {\em root default:} \lstinline=/bin/bash= 
\end{myitemize}


\paragraph[{[[[}remote{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]]}

Configur host and username, for tasks that do not run on the suite host.
Cylc will use passwordless ssh to submit the task by the configured
job submission method. Cylc must be installed on remote task hosts, but
of the external software dependencies only Pyro is required there
(actually, not even that if {\em ssh messaging} is used; see below).
Passwordless ssh must be configured between the local suite owner on the
suite host, and the task owner on the remote task host.

\subparagraph[host]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ host}
\label{DynamicHostSelection}

The remote host for this namespace. This can be a static hostname or a
command that prints a suitable hostname to stdout. Host selection
commands are executed just prior to job submission. The host (static or
dynamic) may have an entry in the cylc site or user config file to
specify parameters such as the location of cylc on the remote machine;
if not, the corresponding local settings (on the suite host) will be
assumed to apply on the remote host. 

\begin{myitemize}
\item {\em type:} string (a valid hostname on the network)
\item {\em default:} (none)
\item {\em examples:}
    \begin{myitemize}
        \item static host name: \lstinline@host = foo@
        \item fully qualified: \lstinline@host = foo.bar.baz@
        \item dynamic host selection: \lstinline@host = $(host-selector.sh)@ 
        \item dynamic host selection: \lstinline@host = `host-selector.sh)`@ (back-tick version)
    \end{myitemize}
\end{myitemize}


\subparagraph[owner]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ owner}

The task owner username. This is (only) used in the passwordless ssh
command line  invoked by cylc to submit the remote task (consequently it
may be defined using local environment variables 
(i.e.\ the shell in which cylc runs, and [cylc] $\rightarrow$ [[environment]]). 

\begin{myitemize}
\item {\em type:} string (a valid username on the remote host)
\item {\em default:} (none)
\end{myitemize}

\subparagraph[suite definition directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$  suite definition directory}

The path to the suite definition directory on the remote host, needed if
remote tasks require access to files stored there (via
\lstinline=$CYLC_SUITE_DEF_PATH=) or in the suite bin directory (via
\lstinline=$PATH=).  If this item is not defined, the local suite
definition directory path will be assumed, with the suite owner's home
directory, if present, replaced by \lstinline='$HOME'= for
interpretation on the remote host. 

\begin{myitemize}
\item {\em type:} string (a valid directory path on the remote host)
\item {\em default:} (local suite definition path with \lstinline=$HOME=
    replaced)
\end{myitemize}
 

\paragraph[{[[[}event hooks{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]]}
\label{TaskEventHandling}

See Section~\ref{SuiteEventHandling} (Suite Event Hooks) for a general
description of cylc event handling. This section is specific to task events. 
The command \lstinline=cylc [hook] email-task= is a ready-made task event 
handler. 

Custom task event handlers can be located in the suite bin directory,  
in which case you will not need to modify your \lstinline=$PATH= to ensure
they are found.  They are called by cylc with the following arguments:
\begin{lstlisting}
<handler> EVENT SUITE TASK MESSAGE
\end{lstlisting}
EVENT is the event name (see below), SUITE is the suite name, TASK 
is the task ID, and MESSAGE, if provided, describes what has happened.
Note that {\em spaces in event names will be replaced by underscores 
in the handler argument list} to make parsing easier in the script,
e.g.\ ``submission failed'' becomes ``submission\_failed''.

\subparagraph[EVENT handler]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ EVENT handler}

The handler to call when the task event EVENT occurs. Repeat this
section for each of the following task events that you wish to handle:
\begin{myitemize}
    \item `submitted' - the task was submitted
    \item `started' - the task started running 
    \item `succeeded' - the task succeeded
    \item `failed' - the task failed
    \item `submission failed' - the task failed in job submission
    \item `warning' - the task reported a warning message
    \item `retry' - the task failed but will retry
    \item `submission timeout' - task job submission timed out
    \item `execution timeout' - task execution timed out
\end{myitemize}
MESSAGE, if provided, describes what has happened, and TASKID identifies
the task (\lstinline=NAME.CYCLE= for cycling tasks).

\begin{myitemize}
    \item {\em type:} string (the event handler)
    \item {\em default:} None
    \item {\em example:} \lstinline@failed handler = my-handler.sh@
\end{myitemize}

To handle timeouts you must also specify a timeout value, below.

\subparagraph[submission timeout]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ submission timeout}

If a task has not started the specified number of minutes after it was
submitted, the event handler will be called by cylc with 
{\em submission\_timeout} as the EVENT argument:
\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[execution timeout]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ execution timeout}

If a task has not finished the specified number of minutes after it
started running, the event handler will be called by cylc with {\em
execution\_timeout} as the EVENT argument:
\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[reset timer]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ reset timer}

If you set an execution timeout the timer can be reset to zero every
time a message is received from the running task (which indicates the 
task is still alive).  Otherwise, the task will timeout if it does not
finish in the alotted time regardless of incoming messages.

\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} False
\end{myitemize}

\paragraph[{[[[}environment{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment]]]}

The user defined task execution environment. Variables defined here can
refer to cylc suite and task identity variables, which are exported
earlier in the task job script, and variable assignment expressions can
use cylc utility commands because access to cylc is also configured
earlier in the script.  See also {\em Task Execution Environment},
Section~\ref{TaskExecutionEnvironment}.

\subparagraph[\_\_VARIABLE\_\_ ]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment]]] $\rightarrow$ \_\_VARIABLE\_\_}
\label{AppendixTaskExecutionEnvironment}

Replace \_\_VARIABLE\_\_ with any number of environment variable
assignment expressions.
Order of definition is preserved so values can refer to previously
defined variables. Values are passed through to the task job script
without evaluation or manipulation by cylc, so any variable assignment
expression that is legal in the job submission shell can be used. 
White space around the `$=$' is allowed (as far as cylc's suite.rc 
parser is concerned these are just normal configuration items).

\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\item {\em legal values:} depends to some extent on the task job
    submission shell (Section~\ref{JobSubShell}). 
\item {\em examples}, for the bash shell: 
   \begin{myitemize}
       \item \lstinline@FOO = $HOME/bar/baz@
       \item \lstinline@BAR = ${FOO}$GLOBALVAR@
       \item \lstinline@BAZ = $( echo "hello world" )@
       \item \lstinline@WAZ = ${FOO%.jpg}.png@
       \item \lstinline@NEXT_CYCLE = $( cylc cycletime -a 6 )@
       \item \lstinline@PREV_CYCLE = `cylc cycletime -s 6`@
       \item \lstinline@ZAZ = "${FOO#bar}" # <-- QUOTED to escape the suite.rc comment character@ 
   \end{myitemize}
\end{myitemize}

\paragraph[{[[[}directives{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[directives]]]}

Batch queue scheduler directives.  Whether or not these are used depends
on the job submission method. For the built-in loadleveler, pbs, and sge
methods directives are written to the top of the task job script in
the correct format for the method. Specifying directives individually
like this allows use of default directives that can be individually
overridden at lower levels of the runtime namespace hierarchy.

\subparagraph[\_\_DIRECTIVE\_\_ ]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[directives]]] $\rightarrow$ \_\_DIRECTIVE\_\_}

Replace \_\_DIRECTIVE\_\_ with each directive assignment, e.g. 
\lstinline@class = parallel@

\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\end{myitemize}

Example directives for the built-in job submission methods are shown in
Section~\ref{AvailableMethods}.

\paragraph[{[[[}outputs{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[outputs]]]}

This section is only required if other tasks need to trigger off specific
internal outputs of this task (as opposed to triggering off it finishing).
The task implementation must report the specified output messages 
by calling \lstinline=cylc task message= when the
corresponding real outputs have been completed.

\subparagraph[\_\_OUTPUT\_\_ ]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[outputs]]] $\rightarrow$ \_\_OUTPUT\_\_}

Replace \_\_OUTPUT\_\_ with any number of labelled output messages. 
\begin{myitemize}
    \item {\em type:} string (a message containing
        \lstinline=<CYLC_TASK_CYCLE_TIME>= with an optional offset as shown
        below. Note that you cannot use the corresponding shell variable
        \lstinline=$CYLC_TASK_CYCLE_TIME= here. The string substitution
        (replacing this special variable with the actual task cycle time) is
        done inside cylc, not in the task execution environment.
\item {\em default:} (none)
\item{ \em examples:}
 \begin{lstlisting}
 foo = "sea state products ready for <CYLC_TASK_CYCLE_TIME>"
 bar = "nwp restart files ready for <CYLC_TASK_CYCLE_TIME+6>"
 \end{lstlisting}
 where the item name must match the output label associated with
 this task in the suite dependency graph, e.g.:
\lstset{language=suiterc}
\begin{lstlisting}
[scheduling]
    [dependencies]
        graph = TaskA:foo => TaskB
 \end{lstlisting}
\end{myitemize}
\lstset{language=transcript}

\subsection{[visualization]}

Configuration of suite graphing and, where explicitly stated, the
graph-based suite control GUI.

\subsubsection[initial cycle time]{[visualization] $\rightarrow$ initial cycle time}

The first cycle time to use when plotting the suite dependency graph.
\begin{myitemize}
    \item {\em type:} integer
    \item {\em default:} 2999010100
\end{myitemize}

\subsubsection[final cycle time]{[visualization] $\rightarrow$ final cycle time}

The last cycle time to use when plotting the suite dependency graph.
Typically this should be just far enough ahead of the initial cycle to
show the full suite.

\begin{myitemize}
    \item {\em type:} integer
    \item {\em default:} 2999010123
\end{myitemize}

\subsubsection[collapsed families]{[visualization] $\rightarrow$ collapsed families}

A list of family (namespace) names to be shown in the collapsed state
(i.e.\ the family members will be replaced by a single family node) when
the suite is plotted in the graph viewer or the gcylc graph view. This
item determines how family groups are shown 
{\em initially} in the suite control GUI; subsequently you can use the
interactive controls to group and ungroup nodes at will. For the same
reason (presence of interactive grouping controls) this item is ignored
if the suite is reparsed during graph viewing (other changes to graph
styling will be picked up and applied if the graph viewer detects that
the suite.rc file has changed). 

\begin{myitemize}
    \item {\em type:} list of family names
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[use node color for edges]{[visualization] $\rightarrow$ use node color for edges}

Graph edges (dependency arrows) can be plotted in the same color
as the upstream node (task or family) to make paths through a complex
graph easier to follow.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} True
\end{myitemize}

\subsubsection[use node color for labels]{[visualization] $\rightarrow$ use node color for labels}

Graph node labels can be printed in the same color as the node outline.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}


\subsubsection[default node attributes]{[visualization] $\rightarrow$ default node attributes}

Set the default attributes (color and style etc.) of graph nodes (tasks and families).
Attribute pairs must be quoted to hide the internal \lstinline@=@ character.

\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} \lstinline@'style=unfilled', 'color=black', 'shape=box'@
\end{myitemize}

\subsubsection[default edge attributes]{[visualization] $\rightarrow$ default edge attributes}

Set the default attributes (color and style etc.) of graph edges
(dependency arrows).  Attribute pairs must be quoted to hide the
internal \lstinline@=@ character.
\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} \lstinline@'color=black'@
\end{myitemize}

\subsubsection[enable live graph movie]{[visualization] $\rightarrow$ enable live graph movie}

If True, the graph-based suite control GUI will write out a dot-language
graph file on every change; these can be post-processed into a movie
showing how the suite evolves. The frames will be written to the run
time graph directory (see below).

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} \lstinline@False@
\end{myitemize}

\subsubsection[{[[}node groups{]]}]{[visualization] $\rightarrow$ [[node groups]]}

Define named groups of graph nodes (tasks and families) which can styled
en masse, by name, in [visualization] $\rightarrow$ [[node attributes]].
Node groups are automatically defined for all task families, including
root, so you can style family and member nodes at once by family name.

\paragraph[\_\_GROUP\_\_]{[visualization] $\rightarrow$ [[node groups]] $\rightarrow$ \_\_GROUP\_\_}

Replace \_\_GROUP\_\_ with each named group of tasks or families.

\begin{myitemize}
    \item {\em type:} comma separated list of task or family names
    \item {\em default:} (none)
    \item {\em example:}
\begin{lstlisting}
   PreProc = foo, bar
   PostProc = baz, waz
\end{lstlisting}
\end{myitemize}

\subsubsection[{[[}node attributes{]]}]{[visualization] $\rightarrow$ [[node attributes]]}

Here you can assign graph node attributes to specific nodes, or to all
members of named groups defined in [visualization] $\rightarrow$ [[node
groups]] (task families are automatically node groups). Group styling 
can be overridden for individual nodes or subgroups.

\paragraph[\_\_NAME\_\_]{[visualization] $\rightarrow$ [[node attributes]] $\rightarrow$ \_\_NAME\_\_}

Replace \_\_NAME\_\_ with each node or node group for style attribute
assignment.

\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} (none)
    \item {\em example:} (with reference to the node groups defined above)
\begin{lstlisting}
   PreProc = 'style=filled', 'color=blue'
   PostProc = 'color=red'
   foo = 'style=unfilled'
\end{lstlisting}
\end{myitemize}

\subsubsection[{[[}runtime graph{]]}]{[visualization] $\rightarrow$ [[runtime graph]]}

Cylc can generate graphs of dependencies resolved at run time, i.e.\ what 
actually triggers off what as the suite runs. This feature is retained
mainly for development and debugging purposes. You can use simulation
mode or dummy mode to generate runtime graphs very quickly.

\paragraph[enable]{[visualization] $\rightarrow$ [[runtime graph]] $\rightarrow$ enable}

Runtime graphing is disabled by default.
\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[cutoff]{[visualization] $\rightarrow$ [[runtime graph]] $\rightarrow$ cutoff}

New nodes will be added to the runtime graph as the corresponding tasks
trigger, until their cycle time exceeds the initial cycle time by more
than this cutoff, in hours.

\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, hours)
    \item {\em default:} $24$
\end{myitemize}

\paragraph[directory]{[visualization] $\rightarrow$ [[runtime graph]] $\rightarrow$ directory}

Where to put the runtime graph file, \lstinline=runtime-graph.dot=.

\begin{myitemize}
    \item {\em type:} string (a valid directory path, may contain environment variables)
    \item {\em default:} \lstinline=$CYLC_SUITE_DEF_PATH/graphing=
\end{myitemize}

% HIDDEN \subsection{[development]}
% HIDDEN \subsubsection[use quick task elimination]{[development] $\rightarrow$ use quick task elimination }
% HIDDEN     default True

\subsection{Special Placeholder Variables In Suite Definitions}

See Section~\ref{SPHV}.


\subsection{Default Suite Configuration}
\label{SuiteDefaults}

Cylc provides, via \lstinline=$CYLC_DIR/conf/suiterc/*.spec=, sensible
default values for many configuration items so that most users will not
need to explicitly configure log directories and so on. The defaults are
sufficient, in fact, to allow test suites defined by dependency graph
alone (command scripting, for example, defaults to printing a simple
message, sleeping for a few seconds, and then exiting). 

The \lstinline=cylc get-config= command parses a suite definition and
retrieves configuration values for individual items, sections, or entire
suites.

