#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC SUITE ENGINE.
#C: Copyright (C) 2008-2014 Hilary Oliver, NIWA
#C:
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
from cylc.remote import remrun
if remrun().execute():
    sys.exit(0)

import os
from cylc.CylcOptionParsers import cop
from cylc.scheduler import scheduler
from cylc.run import main
from cylc.command_prep import prep_file
import datetime

class start( scheduler ):
    def __init__( self ):
        usage = """cylc [control] run|start [OPTIONS] ARGS

Start a suite from scratch. To restart from a previous state see the
'cylc restart' command.

Suites run in daemon mode unless -n/--no-detach or --debug is used.

The following are all equivalent if no intercycle dependence exists:
  1/ Cold start (default)    : use special cold-start tasks
  2/ Warm start (-w,--warm)  : assume a previous cycle
  3/ Raw  start (-r,--raw)   : assume nothing

1/ COLD START -- any designated cold-start tasks will be inserted in the
waiting state. The variable $CYLC_SUITE_INITIAL_CYCLE_POINT will be set
to the initial cycle point, in task environments.

2/ WARM START -- any designated cold-start tasks will be inserted in the
succeeded state, to stand in for a previous cycle. The variable
$CYLC_SUITE_INITIAL_CYCLE_POINT will be set to 'None' in task environments
unless '--ict' is used.

3/ RAW START -- do not insert any cold-start tasks (mainly for testing).

In task environments, $CYLC_SUITE_FINAL_CYCLE_POINT is always set to the
final cycle point if one is set (by suite.rc file or command line). The
initial and final cycle point variables persists across suite restarts."""

        self.parser = cop( usage, jset=True, argdoc=[ ("REG", "Suite name"),
                ("[START_POINT]", """Initial cycle point or 'now'; overrides the
                         suite definition.""")])

        self.parser.add_option( "--non-daemon",
                help="(deprecated: use --no-detach)",
                action="store_true", default=False, dest="no_detach" )

        self.parser.add_option( "-n", "--no-detach",
                help="Do not daemonize the suite",
                action="store_true", default=False, dest="no_detach" )

        self.parser.add_option( "--profile",
                help="Output profiling (performance) information",
                action="store_true", default=False, dest="profile_mode" )

        self.parser.add_option( "-w", "--warm", help="Warm start the suite",
                action="store_true", default=False, dest="warm" )

        self.parser.add_option( "-r", "--raw", help="Raw start the suite",
                action="store_true", default=False, dest="raw" )

        self.parser.add_option( "--ict",
                help="Set $CYLC_SUITE_INITIAL_CYCLE_POINT to the initial "
                "cycle point even in a warm start (as for cold starts).",
                action="store_true", default=False, dest="set_ict" )

        scheduler.__init__( self )

    def parse_commandline( self ):
        ( self.options, self.args ) = self.parser.parse_args()

        self.suite, self.suiterc = prep_file( self.args[0], self.options ).execute()

        self.suite_dir = os.path.dirname( self.suiterc )

        # For user-defined job submission methods:
        sys.path.append( os.path.join( self.suite_dir, 'python' ))

        if len( self.args ) == 2:
            self._cli_start_string = self.args[1]
            if self._cli_start_string == "now":
                # TODO ISO: will it ever be useful to have this in minutes?
                self._cli_start_string = (
                    datetime.datetime.utcnow().strftime("%Y%m%dT%HZ")
                )

        scheduler.parse_commandline( self )

        if self.options.warm:
            self.load_tasks = self.load_tasks_warm
        elif self.options.raw:
            self.load_tasks = self.load_tasks_raw
        else:
            self.load_tasks = self.load_tasks_cold

    def load_tasks_cold( self ):
        if self.start_point is not None:
            self.log.info( 'Cold Start ' + str(self.start_point) )

        task_list = self.filter_initial_task_list( self.config.get_task_name_list() )

        for name in task_list:
            if name in self.asynchronous_task_list:
                tag = '1' # asynchronous tasks start with tag = 1
            else:
                if self.start_point is not None:
                    tag = self.start_point
                else:
                    # no initial cycle point: we can't load cycling tasks
                    continue
            itask = self.config.get_task_proxy( name, tag, 'waiting', stopctime=None, startup=True, submit_num=0, exists=False )

            if itask.tag:
                self.pool.add( itask )
            else:
                self.log.info( "Not loading " + name + " (out of sequence bounds)" )
                del itask



    def load_tasks_warm( self ):
        if self.start_point is not None:
            self.log.info( 'Warm Start ' + str(self.start_point) )

        task_list = self.filter_initial_task_list( self.config.get_task_name_list() )
        coldstart_tasks = self.config.get_coldstart_task_list()
        startup_tasks = self.config.get_startup_task_list()
        if len( coldstart_tasks ) == 0:
            self.log.info( "This suite has not defined any cold start tasks" )
        for name in task_list:
            # (startup=True is only for cold start)
            if name in self.asynchronous_task_list:
                tag = '1' # TODO ISO: no longer applicable
            else:
                if self.start_point is not None:
                    tag = self.start_point
                else:
                    # no initial cycle point: we can't load cycling tasks
                    continue
            itask = self.config.get_task_proxy( name, tag, 'waiting', stopctime=None, startup=False, submit_num=0, exists=False )
            if name in coldstart_tasks:
                itask.log( "NORMAL", "warm start: starting in succeeded state" )
                itask.state.set_status( 'succeeded' )
                itask.prerequisites.set_all_satisfied()
                itask.outputs.set_all_completed()
            if name in startup_tasks:
                itask.log( "NORMAL", "This is a warm start: I will self-destruct." )
                del itask
                continue

            self.pool.add( itask )

    def load_tasks_raw( self ):
        if self.start_point is not None:
            self.log.info( 'Raw Start ' + str(self.start_point) )

        task_list = self.filter_initial_task_list( self.config.get_task_name_list() )

        coldstart_tasks = self.config.get_coldstart_task_list()
        startup_tasks = self.config.get_startup_task_list()

        for name in task_list:
            # startup=True only for cold start
            if name in self.asynchronous_task_list:
                tag = '1' # asynchronous tasks start with tag = 1
            else:
                if self.start_point is not None:
                    tag = self.start_point
                else:
                    # no initial cycle point: we can't load cycling tasks
                    continue
            itask = self.config.get_task_proxy( name, tag, 'waiting', stopctime=None, startup=False, submit_num=0, exists=False )
            if name in coldstart_tasks or name in startup_tasks:
                itask.log( "NORMAL", "This is a raw start: I will self-destruct." )
                del itask
                continue

            self.pool.add( itask )

if __name__ == '__main__':
    main("run", start)
