#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC FORECAST SUITE METASCHEDULER.
#C: Copyright (C) 2008-2012 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os, sys
import gtk
import warnings
warnings.filterwarnings('ignore', 'use the new', Warning)
from optparse import OptionParser

sys.path.append(os.path.dirname(os.path.abspath(__file__)) + '/../lib')
sys.path.append(os.path.dirname(os.path.abspath(__file__)) + '/../')
from conf.CylcGlobals import cylc_tmpdir
from cylc.hostname import hostname
from cylc.version import compat

# check Pyro is installed
try:
    import Pyro.constants
except Exception, x:
    raise SystemExit('ERROR: Pyro is not installed (or not accessible)')

from cylc import port_scan
from cylc.passphrase import passphrase
from cylc.gui.gcylc import MainApp
from cylc.gui.SuiteControl import ControlApp
from cylc.config import config, SuiteConfigError
from cylc.registration import dbgetter, RegistrationError

# Make current working directory be $HOME. Otherwise (1) if the user
# attempts to start gcylc from a CWD that has been removed, Pyro will
# not be importable below; and (2) if the CWD gets removed later while
# gcylc is running, subprocesses spawned by gcylc will fail when they
# attempt to determine their CWD.
os.chdir(os.environ['HOME'])

parser = OptionParser( """cylc gcylc [SUITE]
       gcylc [SUITE]

This is the cylc graphical user interface. It is functionally equivalent
to the command line interface ('cylc help') in most respects.

    1/ gcylc &
This invokes the gcylc main window, which displays suites in your
private registration database, and in the central database available to
all users. By right-clicking on suites or registration groups you can
gain access to all cylc functionality, from editing and graphing through
to suite control and monitoring.

    2/ gcylc [-g,--graph] SUITE &
This directly invokes a suite control and monitoring application for a
particular suite. Alternatively you can get this by right-clicking on 
the suite in the main gcylc suite database viewer (1/ above). Without
the -g option the GUI will show a filtered text treeview on startup;
with it, the startup view will be dependency graph based.

NOTE: daemonize important suites with the POSIX nohup command:
    $ nohup gcylc [options] SUITE &

Arguments:
    SUITE      Target suite.""")

#parser.add_option( "--host",
#        help="cylc suite host (defaults to localhost).",
#        metavar="HOST", action="store", default=hostname,
#        dest="host" )

parser.add_option( "-g", "--graph",
        help="With SUITE - invoked the new dependency graph based suite "
        "control and monitoring interface.",
        action="store_true", default=False, dest="depgraph" )

( options, args ) = parser.parse_args()

if len(args) != 0 and len(args) != 1:
    parser.error( "Wrong number of arguments" )

imagedir = os.environ[ 'CYLC_DIR' ] + '/images'

#host = options.host
host = hostname
owner = os.environ["USER"]

if len( args ) == 1:
    if args[0] == 'help':
        parser.print_help()
        sys.exit(0)

if len( args ) == 0:
    app = MainApp( host, cylc_tmpdir, imagedir )
    gtk.main()
    sys.exit(0)

reg = args[0]

# get suite definition directory
dbg = dbgetter()
try:
    suite, suiterc = dbg.get_suite(reg)
except RegistrationError, x:
    raise SystemExit(x)

compat( suite, suiterc ).execute( sys.argv )

suite_dir = os.path.dirname(suiterc)

# get suite logging directory
try:
    conf = config( suite, suiterc )
except SuiteConfigError,x:
    raise SystemExit(x)

logging_dir = os.path.join( conf['cylc']['logging']['directory'] )

# scan for suite port
try:
    port = port_scan.get_port( suite )
except:
    port = None
    #print "Suite " + suite + " is not running"
else:
    print "Suite " + suite + " is running on port " + str(port)

# Export the suite's "cylc local environment" here - gcylc spawns
# external processes via the shell so the suite owner could want 
# variables to affect these processes. Example: the ssh process to 
# retrieve remote task output: 
#   ssh owner@foobar 'cat $HOME/path/to/log/file'
# owner is defined as "nwp_$SYS" and $SYS is computed from $HOME.
senv = conf['cylc']['environment']
for var in senv:
    os.environ[var] = os.path.expandvars(senv[var])

gtk.settings_get_default().set_long_property("gtk-toolbar-icon-size", gtk.ICON_SIZE_SMALL_TOOLBAR, "main")
gtk.settings_get_default().set_long_property("gtk-button-images", True, "main")
gtk.settings_get_default().set_long_property("gtk-menu-images", True, "main")

if options.depgraph:
    views = ["graph"]
else:
    views = ["led", "tree"]

app = ControlApp( suite, owner, host, port, suite_dir, logging_dir, imagedir, cylc_tmpdir, views )
gtk.main()
