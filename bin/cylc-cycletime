#!/usr/bin/env python
# -*- coding: utf-8 -*-

#C: THIS FILE IS PART OF THE CYLC SUITE ENGINE.
#C: Copyright (C) 2008-2014 Hilary Oliver, NIWA
#C:
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os, sys, re
import cylc.cycling.iso8601
import isodatetime.data
import isodatetime.dumpers
import isodatetime.parsers
from optparse import OptionParser

parser = OptionParser( usage = """cylc [util] cycletime [OPTIONS] [CYCLE]

Arithmetic cycle time offset computation, and filename templating.

Examples:

1) print offset from an explicit cycle time:
  % cylc [util] cycletime --offset-hours=6 20100823T1800Z
  20100824T0000Z

2) print offset from $CYLC_TASK_CYCLE_TIME (as in suite tasks):
  % export CYLC_TASK_CYCLE_TIME=20100823T1800Z
  % cylc cycletime --offset-hours=-6
  20100823T1200Z

3) cycle time filename templating, explicit template:
  % export CYLC_TASK_CYCLE_TIME=2010-08
  % cylc cycletime --offset-years=2 --template=foo-YYYY-MM.nc
  foo-2012-08.nc

4) cycle time filename templating, template in a variable:
  % export CYLC_TASK_CYCLE_TIME=2010-08
  % export MYTEMPLATE=foo-YYYY-MM.nc
  % cylc cycletime --offset-years=2 --template=MYTEMPLATE
  foo-2012-08.nc

Arguments:
   [CYCLE]  ISO 8601 date-time, e.g. 20140201T0000Z, default
      $CYLC_TASK_CYCLE_TIME""" )

parser.add_option( "--offset-hours", metavar="HOURS",
        help="Add N hours to CYCLE (may be negative)",
        action="store", dest="offsethours" )

parser.add_option( "--offset-days", metavar="DAYS",
        help="Add N days to CYCLE (N may be negative)",
        action="store", dest="offsetdays" )

parser.add_option( "--offset-months", metavar="MONTHS",
        help="Add N months to CYCLE (N may be negative)",
        action="store", dest="offsetmonths" )

parser.add_option( "--offset-years", metavar="YEARS",
        help="Add N years to CYCLE (N may be negative)",
        action="store", dest="offsetyears" )

parser.add_option( "--offset", metavar="ISO_OFFSET",
        help="Add an ISO 8601-based interval representation to CYCLE",
        action="store", dest="offset" )

parser.add_option( "--template", metavar="TEMPLATE",
        help="Filename template string or variable",
        action="store", dest="template" )

parser.add_option( "--time-zone", metavar="TEMPLATE",
        help=("Control the formatting of the result's timezone e.g. " +
              "(Z, +13:00, -hh"),
        action="store", default=None, dest="time_zone" )

parser.add_option( "--num-expanded-year-digits", metavar="NUMBER",
        help=("Specify a number of expanded year digits to print in the " +
              "result"),
        action="store", default=0, dest="num_expanded_year_digits" )

parser.add_option( "--print-year", help="Print only YYYY of result",
        action="store_true", default=False, dest="print_year" )

parser.add_option( "--print-month", help="Print only MM of result",
        action="store_true", default=False, dest="print_month" )

parser.add_option( "--print-day", help="Print only DD of result",
        action="store_true", default=False, dest="print_day" )

parser.add_option( "--print-hour", help="Print only HH of result",
        action="store_true", default=False, dest="print_hour" )


(options, args) = parser.parse_args()

# TODO ISO - THIS UTIL WILL BE COMPLETELY BROKEN
if len( args ) == 0:
    # input cycle time must be definied in the environment.
    if 'CYLC_TASK_CYCLE_TIME' not in os.environ:
        parser.error( "Provide CYCLE arg, or define $CYLC_TASK_CYCLE_TIME" )
    cycle = os.environ['CYLC_TASK_CYCLE_TIME'] 

elif len( args ) == 1:
    # must be cycle time
    cycle = args[0]

else:
    parser.error( "Wrong number of arguments!" )

# template string
template = None
if options.template:
    if options.print_month or options.print_year or \
            options.print_day or options.print_hour:
                parser.error( '"print only" options are incompatible with templating' )
    tmp = options.template
    if tmp in os.environ:
        # name of a variable that contains a template
        template = os.environ[ tmp ]
    else:
        # or a raw template string
        template = tmp
else:
    n_chosen = 0

    if options.print_year:
        n_chosen +=1
        if options.num_expanded_year_digits:
            template = u"Â±XCCYY"
        else:
            template = "CCYY"

    if options.print_month:
        n_chosen +=1
        template = "MM"

    if options.print_day:
        n_chosen +=1
        template = "DD"

    if options.print_hour:
        n_chosen +=1
        template = "%H"

    if n_chosen != 0 and n_chosen != 1:
        parser.error( "Choose NONE or ONE of print_(year|month|day|hour)" )

if (template is None and re.match("\d{10}$", cycle)):
    # Auto-detect prev Cylc format.
    template="%Y%m%d%H"

cylc.cycling.iso8601.init(
    num_expanded_year_digits=options.num_expanded_year_digits,
    time_zone=options.time_zone
)
iso_point_parser = isodatetime.parsers.TimePointParser(
    num_expanded_year_digits=options.num_expanded_year_digits
)
iso_point_dumper = isodatetime.dumpers.TimePointDumper(
    num_expanded_year_digits=options.num_expanded_year_digits
)
try:
    cycle_point = iso_point_parser.parse(
        cycle, dump_as_parsed=(template is None))
except ValueError:
    # May be in prev Cylc format.
    try:
        cycle_point = cylc.cycling.iso8601.point_parse(cycle)
    except ValueError as exc:
        parser.error( 'ERROR: invalid cycle: ' + str(exc) )

offset_props = {}

if options.offsethours:
    try:
        offset_props["hours"] = int( options.offsethours )
    except ValueError:
        parser.error( 'ERROR: offset must be integer' )

if options.offsetdays:
    try:
        offset_props["days"] = int( options.offsetdays )
    except ValueError:
        parser.error( 'ERROR: offset must be integer' )

if options.offsetmonths:
    try:
        offset_props["months"] = int( options.offsetmonths )
    except ValueError:
        parser.error( 'ERROR: offset must be integer' )

if options.offsetyears:
    try:
        offset_props["years"] = int( options.offsetyears )
    except ValueError:
        parser.error( 'ERROR: offset must be integer' )

offset = isodatetime.data.TimeInterval(**offset_props)

if options.offset:
    opt_offset = options.offset
    sign_factor = 1
    if options.offset.startswith("-"):
        opt_offset = options.offset[1:]
        sign_factor = -1
    try:
        offset += isodatetime.parsers.TimeIntervalParser().parse(
            opt_offset) * sign_factor
    except ValueError as exc:
        parser.error( 'ERROR: offset not valid: ' + str(exc) )
cycle_point += offset
if template is None:
    print cycle_point
else:
    print iso_point_dumper.dump(cycle_point, template)
