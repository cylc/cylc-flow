#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC SUITE ENGINE.
#C: Copyright (C) 2008-2014 Hilary Oliver, NIWA
#C:
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
from cylc.remote import remrun
if remrun().execute():
    sys.exit(0)

from datetime import datetime
import os, re
from cylc.config import TaskNotDefinedError
from cylc.CylcOptionParsers import cop
from cylc.scheduler import scheduler
from cylc.suite_state_dumping import dumper
from cylc.task_state import task_state
from cylc.run import main
from cylc.command_prep import prep_file
import cylc.TaskID
from cylc.cycling.loader import get_point
from cylc.wallclock import get_current_time_string


class restart( scheduler ):
    def __init__( self ):
        usage = """cylc [control] restart [OPTIONS] ARGS

Restart a suite from a previous state. To start from scratch see the
'cylc run' command.

Suites run in daemon mode unless -n/--no-detach or --debug is used.

The most recent previous state is loaded by default, but other states
can be specified on the command line (cylc writes special state dumps
and logs their filenames before actioning intervention commands).

Tasks recorded as 'submitted' or 'running' will be polled to determine
where they got to while the suite was down."""

        self.parser = cop( usage, jset=True, argdoc=[("REG", "Suite name"),
   ( "[FILE]", """Optional state dump file, assumed to reside in the
                        suite state dump directory unless an absolute path
                        is given. Defaults to the most recent suite state.""")])

        self.parser.add_option( "--non-daemon",
                help="(deprecated: use --no-detach)",
                action="store_true", default=False, dest="no_detach" )

        self.parser.add_option( "-n", "--no-detach",
                help="Do not daemonize the suite",
                action="store_true", default=False, dest="no_detach" )

        self.parser.add_option( "--profile",
                help="Output profiling (performance) information",
                action="store_true", default=False, dest="profile_mode" )

        self.parser.add_option( "--ignore-final-cycle",
            help="Ignore the final cycle point in the state dump. If one is"
            "specified in the suite definition it will be used, however.",
            action="store_true", default=False, dest="ignore_stopcycle" )

        self.parser.add_option( "--ignore-initial-cycle",
            help="Ignore the initial cycle point in the state dump. If one is "
            "specified in the suite definition it will be used, however.",
            action="store_true", default=False, dest="ignore_startcycle" )

        scheduler.__init__( self, is_restart=True )

    def parse_commandline( self ):
        ( self.options, self.args ) = self.parser.parse_args()

        self.suite, self.suiterc = prep_file( self.args[0], self.options ).execute()

        self.suite_dir = os.path.dirname( self.suiterc )

        # For user-defined job submission methods:
        sys.path.append( os.path.join( self.suite_dir, 'python' ))

        self.restart_from = None
        if len( self.args ) == 2:
            self.restart_from = self.args[1]

        scheduler.parse_commandline( self )

    def get_state_start_string( self ):
        """Return the start string specified in the state file, if any."""
        return self.get_state_file_info()[0]
        
    def get_state_file_path( self ):
        """Return the state file path that we are restarting from."""
        my_dumper = self.state_dumper
        if my_dumper is None:
            my_dumper = dumper(self.suite)
        base_name = my_dumper.BASE_NAME
        file_name = base_name
        dir_name = my_dumper.dir_name
        if self.restart_from and os.path.isabs(self.restart_from):
            file_name = self.restart_from
        elif self.restart_from:
            file_name = os.path.join(dir_name, self.restart_from)
        else:
            file_name = os.path.join(dir_name, file_name)
        if not os.path.isfile(file_name):
            raise Exception("state dump file not found: " + file_name)
        return os.path.realpath(file_name)

    def get_state_file_info( self ):
        """Return the state file start & stop strings, broadcast, tasks.

        The state dump file format is:
        run mode : <mode> 
        time : <time> (<unix time>)
        class <classname>: item1=value1, item2=value2, ...
        <task_id> : <state>
        <task_id> : <state>
          ...
        task <state> format is defined by task_state.dump()

        """
        file_name = self.get_state_file_path()
        try:
            FILE = open( file_name, 'r' )
        except IOError,x:
            print >> sys.stderr, x
            raise Exception(
                "ERROR, cannot open suite state dump: %s" % file_name)
        lines = FILE.readlines()
        FILE.close()

        nlines = len(lines)
        if nlines == 0:
            raise Exception( "ERROR, empty suite state dump: " + file_name )
        elif nlines < 3:
            print >> sys.stderr, ("ERROR, The suite state dump contains only",
                                  nlines, "lines:")
            for l in lines:
                print ' ', l.rstrip()
            raise Exception(
                "ERROR, incomplete suite state dump: " + file_name)
       
        index = 0
        # run mode : <mode>
        line0 = lines[index].rstrip()
        if line0.startswith( 'suite time' ):
            # backward compatibility for pre-5.4.11 state dumps
            old_run_mode = 'live'
        elif line0.startswith( 'simulation time' ):
            # backward compatibility for pre-5.4.11 state dumps
            old_run_mode = 'simulation'
        else:
            # current state dumps
            old_run_mode = line0.split(' : ')[1]
            index += 1
            # time : <time> (not used here)

        if self.run_mode == 'live' and old_run_mode != 'live':
            raise Exception(
                "ERROR: cannot RESTART in " + self.run_mode + " from a " +
                old_run_mode + " state dump"
            )

        state_start_string = None
        index += 1
        line2 = lines[index]
        line2 = line2.rstrip()
        try:
            label, oldstartcycle = line2.split(' : ')
        except ValueError, x:
            print >> sys.stderr, (
                'ERROR, Illegal state dump line 2 (initial cycle):')
            print >> sys.stderr, ' ', line2
            raise Exception("ERROR: corrupted state dump")
        if oldstartcycle != '(none)':
            state_start_string = oldstartcycle

        state_stop_string = None
        index += 1
        line3 = lines[index]
        line3 = line3.rstrip()
        try:
            label, oldstopcycle = line3.split(' : ')
        except ValueError, x:
            print >> sys.stderr, (
                'ERROR, Illegal state dump line 3 (final cycle):')
            print >> sys.stderr, ' ', line3
            raise Exception("ERROR: corrupted state dump")

        if oldstopcycle != '(none)':
            state_stop_string = oldstopcycle

        # broadcast variables (universal):
        index += 1

        pickled_broadcast = ""
        while True:
            pickled_broadcast += lines[index]
            if pickled_broadcast.endswith(".\n"):
                # every pickle stream ends with a period
                break
            index += 1

        index += 1
        line = lines[index].rstrip()
        if line != 'Begin task states':
            raise Exception(
                "ERROR, illegal state dump line " +
                "(expected 'Begin task states'): " + line
            )

        index += 1

        task_lines = []
        for line in lines[index:]:
            # strip trailing newlines
            task_lines.append(line.rstrip('\n'))
        return (state_start_string, state_stop_string,
                pickled_broadcast, task_lines)

    def load_tasks( self ):

        # FIND THE INITIAL STATE DUMP FILE
        base_name = self.state_dumper.BASE_NAME
        dir_name = self.state_dumper.dir_name
        file_name = self.get_state_file_path()

        self.log.info( 'Restart ' + file_name )
        src_name = file_name
        if os.path.realpath(dir_name) == os.path.dirname(file_name):
            src_name = os.path.basename(file_name)
        now_str = get_current_time_string(use_basic_format=True)
        lnk_name = os.path.join(dir_name, base_name + "-restart." + now_str)
        os.symlink(src_name, lnk_name)

        state_start_string, state_stop_string, broadcast, task_lines = (
            self.get_state_file_info())

        if state_start_string is not None:
            # the state dump prescribes a start cycle
            # (else we take whatever the suite.rc file gives us)
            state_start_point = get_point(state_start_string)
            if self.options.ignore_startcycle:
                # ignore it and take whatever the suite.rc file gives us
                if self.start_point is not None:
                    print >> sys.stderr, """WARNING: I'm ignoring the old initial cycle as requested, but I
  can't ignore the one set in the suite definition."""
            elif self.start_point is not None:
                # a start cycle was given in the suite.rc file
                if self.start_point != state_start_point:
                    # the state dump doesn't lie about start cycles
                    if self.options.ignore_startcycle:
                        print >> sys.stderr, "WARNING: ignoring old initial cycle", state_start_point, "; using suite.rc", self.start_point
                    else:
                        print >> sys.stderr, "WARNING: old initial cycle", state_start_point, "overriding suite.rc", self.start_point
                        self.start_point = state_start_point
            else:
                # reinstate the former start cycle
                self.start_point = state_start_point
        
        if state_stop_string is not None:
            # the state dump prescribes a stop cycle
            # (else we take whatever the command line or suite.rc file gives us)
            state_stop_point = get_point(state_stop_string)
            if self.options.ignore_stopcycle:
                # ignore it and take whatever the command line or suite.rc file gives us
                if self.stop_point is not None:
                    print >> sys.stderr, """WARNING: I'm ignoring the old final cycle as requested, but I
  can't ignore the one set on the command line or in the suite definition."""
            elif self.stop_point is not None:
                # a stop cycle was given on the restart command line or suite.rc file
                if self.stop_point != state_stop_point:
                    print >> sys.stderr, "WARNING: overriding the old stop cycle", state_stop_point, "with", self.stop_point
            else:
                # reinstate the old stop cycle
                self.stop_point = state_stop_point

        self.pool.wireless.load( broadcast )

        # parse each task line and create the task it represents
        tasknames = {}
        taskstates = {}
        taskcycles = []
        for line in task_lines:

            if re.match( '^class', line ):
                # class variables
                [ left, right ] = line.split( ' : ' )
                [ junk, classname ] = left.split( ' ' )
                cls = self.config.get_task_class( classname )
                pairs = right.split( ', ' )
                for pair in pairs:
                    [ item, value ] = pair.split( '=' )
                    cls.set_class_var( item, value )
                continue

            # instance variables
            try:
                ( id, state ) = line.split(' : ')
                ( name, tag ) = cylc.TaskID.split(id)
            except:
                print >> sys.stderr, "ERROR, Illegal line in suite state dump:"
                print >> sys.stderr, " ", line
                raise Exception( "ERROR: corrupted state dump" )
            tasknames[name] = True
            if 'status=submitting,' in state:
                # backward compabitility for state dumps generated prior to #787
                state = state.replace('status=submitting,',
                                      'status=ready,', 1)
            try:
                task_state(state)
            except Exception as e:
                print >> sys.stderr, "ERROR: ", type(e).__name__, e
                raise Exception( "ERROR: corrupted state dump" )
            taskstates[id] = (name, tag, state )
            taskcycles.append(tag)

        taskcycles = list(set(taskcycles))
        cycleinfo = {}
        for cycle in taskcycles:
            res = self.db.get_restart_info(cycle)
            cycleinfo[cycle] = res
        # RESURRECTING TASKS FROM A SUITE STATE DUMP FILE
        #
        # The state of task prerequisites (satisfied or not) and outputs
        # (completed or not) is determined by the recorded task state:
        #
        # 'waiting'    - prerequisites and outputs unsatisified (default)
        # 'held'       - ditto (only waiting tasks can be held)
        #
        # 'queued'     - prerequisites satisfied, outputs not completed
        #                 (only tasks ready to run can get queued)
        # 'ready'      - ditto
        # 'submitted'  - ditto (but see *)
        # 'submit-retrying' - ditto
        # 'running'    - ditto (but see *)
        # 'failed'     - ditto (tasks must run in order to fail)
        # 'retrying'   - ditto (tasks must fail in order to retry)
        # 'succeeded'  - prerequisites satisfied, outputs completed
        #
        # The two 'retrying' states are held states akin to 'queued'.
        #
        # (*) but tasks reloaded with 'submitted' or 'running' are
        # polled to determine what their current true status is.

        initial_task_list = tasknames.keys()
        task_list = self.filter_initial_task_list( initial_task_list )

        print "RELOADING task proxies"

        for id in taskstates:
            name, tag, state = taskstates[id]
            if name not in task_list:
                continue

            print " +", id
            try:
                # startup is True only for a cold start
                if name in cycleinfo[tag].keys():
                    submit_num = cycleinfo[tag][name]
                else:
                    submit_num = 0
                exists = name in cycleinfo[tag].keys()
                
                itask = self.config.get_task_proxy(
                    name, get_point(tag), state, stopctime=None,
                    startup=False, submit_num=submit_num, exists=exists
                )
            except TaskNotDefinedError, x:
                print >> sys.stderr, str(x)
                print >> sys.stderr, "WARNING: ignoring task", name, "from the suite state dump file"
                print >> sys.stderr, "(the task definition has probably been deleted from the suite)."
                continue
            except Exception, x:
                print >> sys.stderr, str(x)
                print >> sys.stderr, "ERROR: could not load task", name, "from the suite state dump file"
                # TODO: Is it safe to have "raise x" here?
                continue

            # see comments above on resurrecting tasks

            # TODO - we should probably use the task.reset_state()
            # methods here, to update the rundb too...

            print "  ", itask.state.get_status()

            if itask.state.is_currently('waiting'):
                pass

            elif itask.state.is_currently('held'):
                # Only waiting tasks get held. These need to be released
                # on restart to avoid the automatic shutdown criterion:
                # if all tasks are succeeded or held (e.g. because they
                # passed the final cycle point) shut down automatically.
                itask.state.set_status('waiting')

            elif itask.state.is_currently('submitted', 'running'):
                itask.prerequisites.set_all_satisfied()
                # get user_at_host from run-db
                user_at_host = None
                row = self.db.get_task_location(name, tag)
                if row and row[0]:
                    user_at_host = row[0]
                    self.old_user_at_host_set.add(str(user_at_host))
                else:
                    print >> sys.stderr, "WARNING:", id, "failed to read user@host from run-db!"

                # get submit_method_id and try_num from run-db
                submit_method_id = try_num = None
                row = self.db.get_task_submit_method_id_and_try(name, tag)
                if row and row[0]:
                    submit_method_id, try_num = row
                else:
                    print >> sys.stderr, "WARNING:", id, "failed to read submit_method_id and try_num from run-db!"

                if None in [ user_at_host, submit_method_id, try_num ]:
                    print >> sys.stderr, "WARNING: cannot determine what happened to " + id
                else:
                    # update the task proxy with submit ID etc.
                    itask.submit_method_id = submit_method_id
                    itask.try_number = try_num
                    itask.user_at_host = user_at_host
                    # poll the task
                    itask.poll()
                    # update poll timers in case regular polling is configured for itask
                    if '@' in user_at_host:
                        owner, host = user_at_host.split('@')
                    else:
                        host = user_at_host
                    itask.submission_poll_timer.set_host( host, set_timer=True )
                    itask.execution_poll_timer.set_host( host, set_timer=True )

            elif itask.state.is_currently( 'queued', 'ready','submit-retrying', 'submit-failed', 'retrying', 'failed'):
                itask.prerequisites.set_all_satisfied()
                if not itask.state.is_currently( 'failed', 'submit-failed' ):
                    # reset to waiting as these had not been submitted yet.
                    itask.state.set_status('waiting')

            elif itask.state.is_currently('succeeded'):
                itask.prerequisites.set_all_satisfied()
                itask.outputs.set_all_completed()

            else:
                raise Exception( 'ERROR: unknown task state for ' + itask.id )

            self.pool.add_to_runahead_pool( itask )


if __name__ == '__main__':
    main("restart", restart)

