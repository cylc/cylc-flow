#!/bin/bash

#C: THIS FILE IS PART OF THE CYLC SUITE ENGINE.
#C: Copyright (C) 2008-2013 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

usage() {
    cat <<eof
USAGE: cylc [admin] test-battery [options] [TOPDIR]

Run a battery of self-diagnosing test-suites. Test batteries should be
kept in a directory tree. Change TOPDIR to target a sub-tree or a single
test suite. TOPDIR defaults to \$CYLC_DIR/tests/, the location of the
official cylc reference tests.

Directory paths containing the word 'hidden' will be ignored. This can
be used to hide sub-suites that are started by test-suites and not
intended as standalone tests (this is how to handle tests that are
supposed to cause a suite to fail: put them in a hidden sub-suite and
have the calling task in the main suite check for the expected result).

Some of the official test suites submit test jobs to a task host and
user account taken from the environment:
  \$CYLC_TEST_TASK_HOST
  \$CYLC_TEST_TASK_OWNER
These default to localhost and \$USER. Passwordless ssh must be
configured to the task host account (even if it is local).

For more information see \"Reference Tests\" in the User Guide.

Options:
  -h, --help   Print this help message and exit.
  -p           Run *all* of the test suites under TOPDIR in parallel
  -n N,        Repeat the whole test battery N times, stopping at the
               first failure (use to find intermittent problems).
eof
}

tally() {
    RET=$1
    if (( $RET == 0 )); then
        echo " ok"
        N_PASSED=$(( N_PASSED + 1 ))
        PASSED="$PASSED $NAME"
    else
        echo "FAILED"
        N_FAILED=$(( N_FAILED + 1 ))
        FAILED="$FAILED $NAME"
    fi
}

# handle long --help
if [[ $@ == *\-\-help ]]; then
    usage
    exit 0
fi

N=1
ITERATE=false
PARALLEL=false
while getopts "phn:" opt; do
    case $opt in 
        h )
        usage
        exit 0
        ;;
        p )
        PARALLEL=true
        ;;
        n )
        N=$OPTARG
        ITERATE=true
        ;;
        ? )
        usage
        exit 0
        ;;
    esac
done

INDENT="  "

shift $(( OPTIND -1 ))
if [[ $# == 1 ]]; then
    SOURCE_DIR=$1
    if [[ $SOURCE_DIR != /* ]]; then
        # abs path:
        SOURCE_DIR=$PWD/$SOURCE_DIR
    fi
elif [[ $# == 0 ]]; then
    SOURCE_DIR=$CYLC_DIR/tests
else
    usage
    exit 1
fi

if [[ $N != [0-9]* ]]; then
    echo "ERROR: -n N (N must be an INTEGER)"
    exit 1
fi

export CYLC_TEST_TASK_HOST=${CYLC_TEST_TASK_HOST:-localhost}
export CYLC_TEST_TASK_OWNER=${CYLC_TEST_TASK_OWNER:-$USER}

ACCOUNT=${CYLC_TEST_TASK_OWNER}@${CYLC_TEST_TASK_HOST}

echo -n "Testing ssh to ${ACCOUNT} ... "
if ! ssh -oBatchmode=yes $ACCOUNT /bin/true > /dev/null 2>&1; then
    echo FAILED
    echo "ERROR: ssh test to $ACCOUNT failed"
    exit 1
else
    echo "ok"
fi

MY_TMPDIR=${CYLC_TMPDIR:-${TMPDIR:-/tmp}}
mkdir -p $MY_TMPDIR

TARGET_DIR=$(mktemp -d)

UNIQ=battery-$$
REG_GROUP=${UNIQ}.$( basename $SOURCE_DIR )

# copy to temp dir
cp -r $SOURCE_DIR $TARGET_DIR

# unreg old suites of the same name (not likely)
cylc unreg -df ${REG_GROUP}'.*' > /dev/null

# register and validate
CWD=$PWD
cd $TARGET_DIR
COUNT=0
declare -a NAMES
declare -a LOGS
echo -n "Registering and validating test suites "
for RC in $( find . -name 'suite.rc' ); do
    # ignore paths containing 'hidden/'
    echo $RC | grep 'hidden/' > /dev/null && continue
    echo -n "."
    DIR=$(dirname $RC)
    NAME=${UNIQ}.$(echo ${DIR#./} | tr '/' '.')
    NAMES[$COUNT]=$NAME
    LOGS[$COUNT]=$(dirname $PWD)/${NAME}.log
    cylc db reg $NAME $DIR > /dev/null || exit 1
    if ! cylc validate $NAME > /dev/null; then
        echo "ERROR: validation failed for $RC"
        exit 1
    fi
    COUNT=$(( COUNT+1 ))
done
echo " ok"

N_TOTAL=$COUNT

cd ..

declare -a PIDS

ITER=1
TOTAL=$N
while (( N > 0 )); do
    if $PARALLEL; then
        echo -n "Running $N_TOTAL suites in parallel"
    else
        echo -n "Running $N_TOTAL suites in sequence"
    fi
    if $ITERATE; then
        echo " ($ITER/$TOTAL)..."
        ITER=$((ITER+1))
    else
        echo " ..."
    fi

N_FAILED=0
N_PASSED=0
PASSED=""
FAILED=""

if $PARALLEL; then
    for I in $( seq 0 $(( ${#NAMES[@]}-1 )) ); do
        # run all tests in the background
        cylc run --reference-test --debug ${NAMES[$I]} > ${LOGS[$I]} 2>&1 &
        PIDS[$I]=$!
    done
    for I in $( seq 0 $(( ${#PIDS[@]}-1 )) ); do
        # wait on all tests in turn
        PID=${PIDS[$I]}
        NAME=${NAMES[$I]}
        LOG=${LOGS[$I]}
        echo -n "${INDENT}$((I+1)). $NAME ($LOG) ..."
        wait $PID
        tally $?
    done
else
    for I in $( seq 0 $(( ${#NAMES[@]}-1 )) ); do
        # run and wait on all tests in the foreground
        echo -n "${INDENT}$((I+1)). ${NAMES[$I]} (${LOGS[$I]}) ..."
        cylc run --reference-test --debug ${NAMES[$I]} > ${LOGS[$I]} 2>&1
        tally $?
    done
fi


echo "${INDENT}SUMMARY:"
if (( N_PASSED == N_TOTAL )); then
    echo "${INDENT} + all $N_TOTAL tests passed"
elif (( N_FAILED == N_TOTAL )); then
    echo "${INDENT} + all $N_TOTAL tests FAILED"
    # exit loop
    break
else
    echo "${INDENT}+ $N_FAILED of $N_TOTAL tests FAILED"
    echo "${INDENT}+ $N_PASSED of $N_TOTAL tests passed"
    # exit loop
    break
fi

N=$(( N-1 ))
done

# unregister successful suites
for REG in $PASSED; do
    cylc unreg -df $REG > /dev/null
done

if (( N_FAILED != 0 )); then
    echo
    echo "${INDENT}Retained failed suite registrations for inspection:"
    for REG in $FAILED; do
        echo "${INDENT} + $REG"
    done
fi

echo
if (( N_FAILED != 0 )); then
    echo "ERROR: test battery failed"
    echo
    exit 1
fi

