#!/bin/bash

#C: THIS FILE IS PART OF THE CYLC SUITE ENGINE.
#C: Copyright (C) 2008-2013 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

usage() {
    cat <<eof
USAGE: cylc [admin] test-battery [options] [TOPDIR]

Run a battery of self-diagnosing test-suites held under TOPDIR, which
defaults to \$CYLC_DIR/tests/.

Paths under TOPDIR containing 'hidden' are ignored; this can be used to
hide sub-suites not intended as standalone tests (e.g. tests that
deliberately cause a suite to fail can be run as sub-suites for which 
the main suite calling tasks check for the expected results).

Some of the official test suites submit test jobs to a task host and
user account taken from the environment:
  \$CYLC_TEST_TASK_HOST
  \$CYLC_TEST_TASK_OWNER
These default to localhost and \$USER. Passwordless ssh must be
configured to the task host account (even if it is local).

Log files and suite run directories are automatically cleaned up on the
suite host, but not on remote task hosts.

For more information see "Reference Tests" in the User Guide.

Options:
  -h, --help   Print this help message and exit.
  -p           Run *all* of the test suites under TOPDIR in parallel
  -n N,        Repeat the whole test battery N times, stopping at the
               first failure (use to find intermittent problems).
  -x           Do not clean up after successful tests (reg, logs).
eof
}

tally() {
    RET=$1
    if (( $RET == 0 )); then
        echo "ok"
        N_PASSED=$(( N_PASSED + 1 ))
        PASS[$NAME]=true
    else
        echo "FAILED"
        N_FAILED=$(( N_FAILED + 1 ))
        PASS[$NAME]=false
    fi
}

inform() {
    echo "${INDENT}${I}. $NAME"
    echo "${INDENT}${INDENT} ${LOGS[$NAME]}"
    echo -n "${INDENT}${INDENT} ${SLOG[$NAME]} ... "
}

# handle long --help
if [[ $@ == *\-\-help ]]; then
    usage
    exit 0
fi

N=1
ITERATE=false
PARALLEL=false
CLEANUP=true
while getopts "pxhn:" opt; do
    case $opt in 
        h )
            usage
            exit 0
            ;;
        p )
            PARALLEL=true
            ;;
        x )
            CLEANUP=false
            ;;
        n )
            N=$OPTARG
            ITERATE=true
            ;;
        ? )
            usage
            exit 0
            ;;
    esac
done

INDENT="  "

shift $(( OPTIND -1 ))
if [[ $# == 1 ]]; then
    SOURCE_DIR=$1
    if [[ $SOURCE_DIR != /* ]]; then
        # abs path:
        SOURCE_DIR=$PWD/$SOURCE_DIR
    fi
elif [[ $# == 0 ]]; then
    SOURCE_DIR=$CYLC_DIR/tests
else
    usage
    exit 1
fi

if [[ $N != [0-9]* ]]; then
    echo "ERROR: -n N (N must be an INTEGER)"
    exit 1
fi

declare -A junk
if [[ $? != 0 ]]; then
    echo "ERROR: your bash version does not support associative arrays."
    exit 1
fi

export CYLC_TEST_TASK_HOST=${CYLC_TEST_TASK_HOST:-localhost}
export CYLC_TEST_TASK_OWNER=${CYLC_TEST_TASK_OWNER:-$USER}

ACCOUNT=${CYLC_TEST_TASK_OWNER}@${CYLC_TEST_TASK_HOST}

echo -n "Testing ssh to ${ACCOUNT} ... "
if ! ssh -oBatchmode=yes $ACCOUNT /bin/true > /dev/null 2>&1; then
    echo FAILED
    echo "ERROR: ssh test to $ACCOUNT failed"
    exit 1
else
    echo "ok"
fi

MY_TMPDIR=${CYLC_TMPDIR:-${TMPDIR:-/tmp}}
mkdir -p $MY_TMPDIR

TARGET_DIR=$(mktemp -d)

UNIQ=battery-$$
REG_GROUP=${UNIQ}.$( basename $SOURCE_DIR )

# copy to temp dir
cp -r $SOURCE_DIR $TARGET_DIR

# unreg old suites of the same name (not likely)
cylc unreg -df ${REG_GROUP}'.*' > /dev/null

# register and validate
CWD=$PWD
cd $TARGET_DIR
COUNT=0
declare -A PIDS
declare -A LOGS # test logs
declare -A SLOG # suite logs
declare -A PRTS # port files
declare -A PASS
echo -n "Registering and validating test suites "
for RC in $( find . -name 'suite.rc' ); do
    # ignore paths containing 'hidden/'
    echo $RC | grep 'hidden/' > /dev/null && continue
    echo -n "."
    DIR=$(dirname $RC)
    NAME=${UNIQ}.$(echo ${DIR#./} | tr '/' '.')
    LOGS[$NAME]=$(dirname $PWD)/${NAME}.log
    # determine suite log and port directories
    SLOG[$NAME]=$( cylc get-global-config | grep 'run directory =' | sed -e 's/.*= //' )/$NAME
    PRTS[$NAME]=$( cylc get-global-config | grep 'ports directory =' | sed -e 's/.*= //' )/$NAME
    cylc db reg $NAME $DIR > /dev/null || exit 1
    if ! cylc validate $NAME > /dev/null; then
        echo "ERROR: validation failed for $RC"
        exit 1
    fi
    COUNT=$(( COUNT+1 ))
done
echo " ok"

N_TOTAL=$COUNT

cd ..

ITER=1
TOTAL=$N
while (( N > 0 )); do
    if $PARALLEL; then
        echo -n "Running $N_TOTAL suites in parallel"
    else
        echo -n "Running $N_TOTAL suites in sequence"
    fi
    if $ITERATE; then
        echo " ($ITER/$TOTAL)..."
        ITER=$((ITER+1))
    else
        echo " ..."
    fi

    N_FAILED=0
    N_PASSED=0

    if $PARALLEL; then
        for NAME in ${!LOGS[@]}; do
            # run all tests in the background
            cylc run --reference-test --debug $NAME > ${LOGS[$NAME]} 2>&1 &
            PIDS[$NAME]=$!
        done
        I=0
        for NAME in ${!LOGS[@]}; do
            # wait on all tests in turn
            I=$(( I + 1 ))
            inform
            wait ${PIDS[$NAME]}
            tally $?
        done
    else
        I=0
        for NAME in ${!LOGS[@]}; do
            # run and wait on all tests in the foreground
            I=$(( I + 1 ))
            inform
            cylc run --reference-test --debug $NAME > ${LOGS[$NAME]} 2>&1
            tally $?
        done
    fi

    echo "${INDENT}SUMMARY:"
    if (( N_PASSED == N_TOTAL )); then
        echo "${INDENT} + all $N_TOTAL tests passed"
    elif (( N_FAILED == N_TOTAL )); then
        echo "${INDENT} + all $N_TOTAL tests FAILED"
        # exit loop
        break
    else
        echo "${INDENT}+ $N_FAILED of $N_TOTAL tests FAILED"
        echo "${INDENT}+ $N_PASSED of $N_TOTAL tests passed"
        # exit loop
        break
    fi

    N=$(( N-1 ))
done

if $CLEANUP; then
    echo -n "${INDENT}Cleaning up successful tests ... "
    for NAME in ${!LOGS[@]}; do
        if ${PASS[$NAME]}; then
            # unregister
            cylc unreg -df $NAME > /dev/null
            # test log
            rm ${LOGS[$NAME]} > /dev/null 2>&1
            # suite log (use '*' to get hidden sub-suites too)
            rm -r ${SLOG[$NAME]}* > /dev/null 2&>1
        else
            # clean up port files left by aborted or killed tests
            rm ${PRTS[$NAME]}* > /dev/null 2&>1
        fi
    done
    echo "ok"
    if (( N_FAILED != 0 )); then
        echo "${INDENT}NOTE: retained registrations and logs for $N_FAILED failed tests"
    fi
else
    echo "${INDENT}NOTE: retained registrations and logs for ALL tests (-x)"
fi 

echo
if (( N_FAILED != 0 )); then
    echo "ERROR: test battery failed"
    exit 1
fi

