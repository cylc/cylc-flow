#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC SUITE ENGINE.
#C: Copyright (C) 2008-2012 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
if '--use-ssh' in sys.argv[1:]: 
    sys.argv.remove( '--use-ssh' )
    from cylc.remote import remrun
    if remrun().execute():
        sys.exit(0)

import os,re,gtk
import warnings
from copy import deepcopy
warnings.filterwarnings('ignore', 'use the new', Warning)
from cylc.CylcOptionParsers import cop
from copy import copy

sys.path.append(os.path.dirname(os.path.abspath(__file__)) + '/../lib')
sys.path.append(os.path.dirname(os.path.abspath(__file__)) + '/../')

from cylc.gui.SuiteControl import ControlApp
from cylc.global_config import globalcfg
from cylc.suite_host import is_remote_host
from cylc.owner import user, is_remote_user
from cylc.registration import localdb
from cylc.passphrase import passphrase
from cylc.task_state import task_state
from cylc.suite_logging import suite_log

from configobj import ConfigObj, ConfigObjError, get_extra_values, flatten_errors, Section
from validate import Validator

class config( object ):

    def __init__( self, list_themes=False, force_theme=None ):
        spec = os.path.join( os.environ['CYLC_DIR'], 'conf', 'gcylcrc', 'cfgspec' )
        dcfg_file = os.path.join( os.environ['CYLC_DIR'], 'conf', 'gcylcrc', 'themes.rc' )
        ucfg_file = os.path.join( os.environ['HOME'], '.cylc', 'gcylc.rc' )
                
        dcfg = {}
        ucfg = {}

        if os.path.isfile( ucfg_file ):
            # load user config
            try:
                ucfg = ConfigObj( infile=ucfg_file, configspec=spec )
            except ConfigObjError, x:
                print >> sys.stderr, x
                print >> sys.stderr, 'WARNING, failed to load gcylc user config: ' + ucfg_file

        if os.path.isfile( dcfg_file ):
            # load default config
            try:
                dcfg = ConfigObj( infile=dcfg_file, configspec=spec )
            except ConfigObjError, x:
                print >> sys.stderr, x
                print >> sys.stderr, 'WARNING, failed to load gcylc default config: ' + dcfg_file

        if not ucfg and not dcfg:
            raise SystemExit( 'ERROR: no gcylc config file found' )

        # validate and load defaults
        cfgs = []
        for cfg in [ ucfg, dcfg ]:
            if cfg:
                cfgs.append(cfg)
        for cfg in cfgs:
            val = Validator()
            test = cfg.validate( val, preserve_errors=False )
            if test != True:
                # Validation failed
                failed_items = flatten_errors( cfg, test )
                # Always print reason for validation failure
                for item in failed_items:
                    sections, key, result = item
                    print >> sys.stderr, ' ',
                    for sec in sections:
                        print >> sys.stderr, sec, ' / ',
                    print >> sys.stderr, key
                    if result == False:
                        print >> sys.stderr, "ERROR, required item missing."
                    else:
                        print >> sys.stderr, result
                raise SystemExit( "ERROR gcylc.rc validation failed")
            extras = []
            for sections, name in get_extra_values( cfg ):
                extra = ' '
                for sec in sections:
                    extra += sec + ' / '
                extras.append( extra + name )
            if len(extras) != 0:
                for extra in extras:
                    print >> sys.stderr, '  ERROR, illegal entry:', extra 
                raise SystemExit( "ERROR illegal gcylc.rc entry(s) found" )

        # combine user config into default config
        self.inherit( dcfg, ucfg )

        # theme inheritance
        if force_theme:
            # override
            dcfg['use theme'] = force_theme
        my_theme = dcfg['use theme']
        if my_theme not in dcfg['themes']:
            raise SystemExit( 'ERROR: theme not defined: ' + my_theme )

        inherited = []
        for label in dcfg['themes']:
            hierarchy = []
            name = label
            while True:
                hierarchy.append(name) 
                if dcfg['themes'][name]['inherit']:
                    parent = dcfg['themes'][name]['inherit']
                    if parent not in dcfg['themes']:
                        raise SystemExit, 'Undefined parent theme: ' + parent
                else:
                    break
                name = parent
            hierarchy.reverse()
            prev = hierarchy[0]
            theme = deepcopy(dcfg['themes'][prev])
            for item in hierarchy[1:]:
                if item in inherited:
                    prev = item
                    continue
                #print 'Inherit:', item, '<--', prev
                self.inherit( theme, dcfg['themes'][item] )
                inherited.append( item )
            dcfg['themes'][label] = theme

        if list_themes:
            for theme in dcfg['themes']:
                print theme
            sys.exit(0)

        # expand theme data
        cfg = {}
        cfg['use theme'] = dcfg['use theme']
        cfg['themes'] = {}
        for theme in dcfg['themes']:
            cfg['themes'][theme] = {}
            if 'defaults' in dcfg['themes'][theme]:
                defs = self.parse_state( theme, 'defaults', dcfg['themes'][theme]['defaults'] )
            else:
                # needed?
                raise SystemExit( 'ERROR, incomplete defaults for ' + theme )
            for item, val in dcfg['themes'][theme].items():
                if item in [ 'inherit', 'defaults' ]:
                    continue
                state = item
                if state not in task_state.allowed_status:
                    raise SystemExit( 'ERROR, illegal task state:' + theme + ' -> ' + state )
                # reverse inherit (override)
                tcfg = deepcopy(defs)
                self.inherit( tcfg, self.parse_state(theme, item, val))
                cfg['themes'][theme][state] = tcfg
        # result:
        self.cfg = cfg

    def parse_state( self, theme, name, cfglist=[] ):
        allowed_keys = ['style', 'color', 'fontcolor']
        allowed_styles = ['filled', 'unfilled']
        cfg = {}
        for item in cfglist:
            key, val = item.split('=')
            if key not in allowed_keys:
                raise SystemExit( 'Error, illegal config: ' + theme + ': '+ name + ' = ' + cfglist )
            if key == 'color' or key == 'fontcolor':
                try:
                    gtk.gdk.color_parse( val )
                except ValueError, x:
                    print >> sys.stderr, 'ERROR', x
                    sys.exit( 'Illegal color: ' + theme + ': ' + name + '="' + item + '"')
            cfg[key] = val
        return cfg

    def inherit( self, target, source ):
        # recursive theme inheritance
        for item in source:
            if isinstance( source[item], dict ):
                if item not in target:
                    target[item] = {}
                self.inherit( target[item], source[item] )
            else:
                if source[item]:
                    target[item] = source[item]

                    
parser = cop( """cylc gui [OPTIONS] [REG]
gcylc [OPTIONS] [REG]

The cylc GUI for suite control etc. Can also be launched by
right-clicking on a suite in cylc dbviewer.

If the '-t,--timeout=' option is used the timeout value will be passed
on to the suite if it is subsequently started from the GUI
(and it will in turn be passed to tasks submitted by the suite).

To customize the task state color theme used by gcylc, copy the file
$CYLC_DIR/conf/gcylc/gcylc.rc.eg to $HOME/.cylc/gcylc.rc and
adapt to your needs. To see what color themes are available, including 
your own, type 'gcylc -l|--list-themes'.

NOTE: daemonize important suites with the POSIX nohup command:
    $ nohup gcylc [OPTIONS] [REG] &""", pyro=True, gcylc=True,
    argdoc=[('[REG]', 'Suite name' )])

parser.add_option( "-w", "--views", metavar="VIEWS", 
        help="Initial view panes for the suite control GUI. "
        "choose one or two, comma separated, from 'dot', "
        "'text', and 'graph'; the default is 'dot,text'",
        action="store", default='dot,text', dest="gviews" )

parser.add_option( "-u", "--use-theme", metavar="NAME",
        help="The task state color and icon theme to use. This overrides the "
        "theme specified in your gcylc.rc file, if any.",
        action="store", default=None, dest="theme" )

parser.add_option( "-l", "--list-themes", 
        help="Print available task state color theme choices "
        "(built-in themes and any in $HOME/.cylc/gcylc.rc).",
        action="store_true", default=False, dest="list_themes" )

parser.remove_option("-f" ) # don't need force (To Do: a read-only GUI)

( options, args ) = parser.parse_args()

globals = globalcfg()
cylc_tmpdir = globals.cfg['temporary directory']

# Make current working directory be $HOME. Otherwise (1) if the user
# attempts to start gcylc from a CWD that has been removed, Pyro will
# not be importable below; and (2) if the CWD gets removed later while
# gcylc is running, subprocesses spawned by gcylc will fail when they
# attempt to determine their CWD.
os.chdir(os.environ['HOME'])

if not options.list_themes:
    if len( args ) == 0:
        sys.exit( "ERROR: please give a suite name" )
    suite = args[0]
    suitedir = None
    # dealias the suite name (an aliased name may be given for local suites)
    if not is_remote_host( options.host ) and not is_remote_user( options.owner ):
        db = localdb(file=options.db, verbose=options.verbose)
        db.load_from_file()
        try:
            suite = db.unalias( suite )
            suitedir = db.getdir( suite )
            suiterc = db.getrc( suite )
        except Exception, x:
            if options.debug:
                raise
            raise SystemExit(x)

    try:
        pphrase = passphrase( suite, options.owner, options.host,
                verbose=options.verbose ).get( options.pfile, suitedir )
    except Exception, x:
        sys.exit(str(x))

# load gcylc.rc
usercfg = config( options.list_themes, options.theme )

gtk.settings_get_default().set_long_property("gtk-toolbar-icon-size", gtk.ICON_SIZE_SMALL_TOOLBAR, "main")
gtk.settings_get_default().set_long_property("gtk-button-images", True, "main")
gtk.settings_get_default().set_long_property("gtk-menu-images", True, "main")

views = (options.gviews).split(',')

if len(views) > 2:
    sys.exit( "ERROR: Too many views specified" )

illegal = []
for view in views:
    if view not in ['dot', 'text', 'graph' ]:
        illegal.append(view)
if len(illegal) != 0:
    sys.exit( "ERROR, illegal view specs: " + ', '.join( illegal))

logdir = suite_log( suite ).get_dir()
try:
    app = ControlApp( suite, suiterc, logdir, pphrase, options.owner,
            options.host, options.port, cylc_tmpdir, views,
            options.pyro_timeout, usercfg.cfg, options.templatevars,
            options.templatevars_file )
except Exception, x:
    if options.debug:
        raise
    raise SystemExit(x)
gtk.main()

