#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC FORECAST SUITE METASCHEDULER.
#C: Copyright (C) 2008-2011 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os, re, sys

sys.path.append(os.path.dirname(os.path.abspath(__file__)) + '/../lib')

from OrderedDict import OrderedDict
from cylc.execute import execute

# check Pyro is installed
try:
    import Pyro.constants
except Exception, x:
    raise SystemExit('ERROR: Pyro is not installed (or not accessible)')

class CommandError( Exception ):
    """
    Attributes:
        message - what the problem is. 
    """
    def __init__( self, msg ):
        self.msg = msg
    def __str__( self ):
        return repr(self.msg)

class CommandNotFoundError( CommandError ):
    pass

class CommandNotUniqueError( CommandError ):
    pass

def is_help( str ):
    if str == '-h' or \
        str == '--help' or \
        str == '--hlep' or \
        str == 'help' or \
        str == 'hlep' or \
        str == '?':
        return True
    else:
        return False

def match_dict( abbrev, categories, title ):
    # allow any unique abbreviation to cylc categories
    matches = []
    for cat in categories.keys():
        for alias in categories[cat]:
            if re.match( '^' + abbrev + '.*', alias ):
                if cat not in matches:
                    matches.append( cat )
    if len( matches ) == 0:
        raise CommandNotFoundError, title + ' not found: ' + abbrev
    elif len( matches ) > 1:
        # multiple matches
        res = ''
        for cat in matches:
            res += ' ' + '|'.join(categories[cat])
        raise CommandNotUniqueError, title + ' "' + abbrev + '" not unique:' + res
    else:
        return matches[0]

def match_command( abbrev ):
    # allow any unique abbreviation to commands when no category is specified
    matches = []
    for dct in [ 
        admin_commands,
        license_commands,
        database_commands, 
        preparation_commands, 
        information_commands, 
        discovery_commands, 
        control_commands, 
        utility_commands,
        task_commands ]:
        for com in dct.keys():
            for alias in dct[com]:
                if re.match( '^' + abbrev + '.*', alias ):
                    if com not in matches:
                        matches.append( com )
    if len( matches ) == 0:
        raise CommandNotFoundError, 'COMMAND not found: ' + abbrev
    elif len( matches ) > 1:
        # multiple matches
        res = ''
        for com in matches:
            res += ' ' + '|'.join(all_commands[com])
        raise CommandNotUniqueError, 'COMMAND "' + abbrev + '" not unique:' + res
    else:
        return matches[0]

def pretty_print( incom, choose_dict, indent=True, numbered=False, sort=False ):
    # pretty print commands or topics from a dict:
    # (com[item] = description)
    
    if indent:
        spacer = ' '
    else:
        spacer = ''

    label = {}
    choose = []
    longest = 0
    for item in choose_dict:
        choose.append( item )
        lbl = '|'.join(choose_dict[item])
        label[item] = lbl
        if len( lbl ) > longest:
            longest = len( lbl )

    count = 0
    pad = False
    if len(choose) > 9:
        pad = True

    if sort:
        choose.sort()
    for item in choose:
        if item not in incom:
            raise SystemExit( "ERROR: summary for '" + item + "' not found" )

        print spacer,
        if numbered:
            count += 1
            if pad and count < 10:
                digit = ' ' + str(count)
            else:
                digit = str(count)
            print digit + '/', 
        print label[item], '.'*(longest-len(label[item])) + '...', incom[item]

# auto-replace with version tag at build/install:
cylc_version = "THIS IS NOT A VERSIONED RELEASE"

# categories[ categorey ] = [ aliases ] 
categories = OrderedDict()
categories['all'         ] = ['all' ]
categories['database'    ] = ['db', 'database' ]
categories['preparation' ] = ['preparation' ]
categories['information' ] = ['information'    ]
categories['discovery'   ] = ['discovery' ]
categories['control'     ] = ['control' ]
categories['utility'     ] = ['utility' ]
categories['task'        ] = ['task' ]
categories['admin'       ] = ['admin' ]
categories['license'     ] = ['license', 'GPL' ]
 
information_commands = OrderedDict()
information_commands['gcylc'    ] = ['gcylc'      ]
information_commands['list'     ] = ['list', 'ls' ]
information_commands['dump'     ] = ['dump'       ]
information_commands['show'     ] = ['show'       ]
information_commands['log'      ] = ['log'        ]
information_commands['monitor'  ] = ['monitor'  ]
information_commands['nudge'    ] = ['nudge' ]
information_commands['get-config'] = ['get-config' ]

control_commands = OrderedDict()
control_commands['gcylc'  ] = information_commands[ 'gcylc' ]
# NOTE: don't change 'run' to 'start' or the category [control]
# becomes compulsory to disambiguate from 'cylc [task] started'.
# Keeping 'start' as an alias however: 'cylc con start'.
control_commands['run'    ] = ['run', 'start' ]
control_commands['stop'] = ['stop', 'shutdown' ]
control_commands['restart'] = ['restart' ]
control_commands['trigger'] = ['trigger' ]
control_commands['insert' ] = ['insert' ]
control_commands['remove' ] = ['remove', 'kill' ]
control_commands['purge'  ] = ['purge' ]
control_commands['hold'   ] = ['hold' ]
control_commands['release' ] = ['release', 'unhold' ]
control_commands['block'  ] = ['block' ]
control_commands['unblock'] = ['unblock' ] 
control_commands['reset'  ] = ['reset'  ]
control_commands['nudge'  ] = ['nudge' ]
control_commands['depend' ] = ['depend']
control_commands['maxrunahead'] = ['maxrunahead']
control_commands['lockserver'] = ['lockserver' ]
control_commands['lockclient'] = ['lockclient', 'lc' ]
control_commands['verbosity' ] = ['verbosity' ]
 
utility_commands = OrderedDict()
utility_commands['cycletime'    ] = ['cycletime' ]
utility_commands['checkvars'    ] = ['checkvars'] 
utility_commands['template'     ] = ['template'] 
utility_commands['housekeeping' ] = ['housekeeping'] 
utility_commands['scp-transfer' ] = ['scp-transfer'] 
utility_commands['email-alert'  ] = ['email-alert'] 
admin_commands = OrderedDict()
admin_commands['create-cdb'  ] = [ 'create-cdb']
admin_commands['test-db'     ] = [ 'test-db']
admin_commands['test-suite'  ] = [ 'test-suite']
admin_commands['check-examples'  ] = [ 'check-examples']

license_commands = OrderedDict()
license_commands['warranty'  ] = [ 'warranty']
license_commands['conditions'] = [ 'conditions']

database_commands = OrderedDict()
database_commands['gcylc'     ] = information_commands['gcylc']
database_commands['register'  ] = [ 'register' ]
database_commands['reregister'] = [ 'reregister','rename' ]
database_commands['alias']      = [ 'alias' ]
database_commands['unregister'] = [ 'unregister' ]
database_commands['copy'      ] = [ 'copy', 'cp' ]
database_commands['print'     ] = [ 'print' ]
database_commands['get-directory' ] = [ 'get-directory' ]
database_commands['export'    ] = [ 'export' ]
database_commands['import'    ] = [ 'import' ]
database_commands['refresh'   ] = [ 'refresh' ]

preparation_commands = OrderedDict()
preparation_commands['gcylc'   ] = information_commands['gcylc']
preparation_commands['edit'    ] = [ 'edit'    ]
preparation_commands['inline'  ] = [ 'inline'    ]
preparation_commands['validate'] = [ 'validate'    ]
preparation_commands['list'    ] = ['list', 'ls' ]
preparation_commands['search'  ] = [ 'search', 'grep' ]
preparation_commands['graph'   ] = [ 'graph'    ]
preparation_commands['diff'    ] = [ 'diff', 'compare' ]
preparation_commands['jobscript' ] = ['jobscript'] 

discovery_commands = OrderedDict()
discovery_commands['ping'] = [ 'ping' ]
discovery_commands['scan'] = [ 'scan' ]

task_commands = OrderedDict()
task_commands['submit'] = [ 'submit', 'single' ]
task_commands['started'] = [ 'started', 'task-started' ]
task_commands['message'] = [ 'message', 'task-message' ]
task_commands['succeeded'] = [ 'succeeded', 'task-succeeded' ]
task_commands['failed'] = [ 'failed', 'task-failed' ]

all_commands = OrderedDict()
for dct in [ 
        database_commands, 
        preparation_commands, 
        information_commands, 
        discovery_commands, 
        control_commands, 
        utility_commands,
        task_commands,
        admin_commands,
        license_commands ]:
    for com in dct.keys():
        all_commands[com] = dct[com]
 
general_usage = """
USAGE:
  cylc -v,--version                               # cylc version
  cylc help,--help,-h,?                           # this help page
  cylc help CATEGORY                              # help by category
  cylc CATEGORY help                              # (ditto)
  cylc help [CATEGORY] COMMAND                    # command help
  cylc [CATEGORY] COMMAND help,--help             # (ditto)
Command syntax:
  cylc [CATEGORY] COMMAND [options] SUITE [arguments]
  cylc [CATEGORY] COMMAND [options] SUITE TASK [arguments]"""

# topic summaries
catsum = OrderedDict()
catsum['all'    ]        = "the complete cylc command set"
catsum['admin'       ]   = "commands for use by the cylc administrator."
catsum['license'     ]   = "Software licensing information (GPL v3.0)."
catsum['database'    ]   = "private and central suite registration."
catsum['information' ]   = "retrieve and print information about a suite."
catsum['preparation' ]   = "suite editing, graphing, validation etc."
catsum['discovery'   ]   = "what suites are running at the moment?"
catsum['control'     ]   = "running, monitoring, and controlling suites."
catsum['task'        ]   = "running single tasks, and task messaging commands."
catsum['utility'     ]   = "cycle time arithmetic, filename templating, etc."

usage = """cylc release version: """ + cylc_version + """
""" + general_usage + """

Commands and categories can be abbreviated. Use of categories is
optional, but they can disambiguate highly abbreviated commands:
  $ cylc control trigger SUITE TASK  # trigger TASK in SUITE
  $ cylc trigger SUITE TASK          # ditto
  $ cylc con trig SUITE TASK         # ditto
  $ cylc c t SUITE TASK              # ditto

SUITE - cylc commands target suites via names registered in a suite
database so that you don't need to continually re-type the actual
location of the suite definition directory on disk. Suite names are
hierarchical like directory paths but delimited by '.' (foo.bar.baz),
allowing suites to be grouped and organised into tree-like structures.

TASK - is a unique identitifier of a task in a suite: NAME%TAG, where
for cycling tasks TAG is a cycle time (YYYYMMDDHH) and for asynchronous
tasks it is an integer (preceded by 'a:' on the command line: foo%a:1).

Here's how to drill down to usage help for a particular command:
  $ cylc help ............... list all available categories (this page)
  $ cylc help prep .......... list commands in category 'preparation'
  $ cylc help prep edit ..... command usage help for 'cylc [prep] edit'

Command CATEGORIES:"""

#Some commands and categories are aliased (db|database, cp|copy) and
#some common typographical errors are corrected (e.g. cycl => cylc).

# command summaries
comsum = OrderedDict()
# admin
comsum[ 'create-cdb' ] = '(ADMIN) Create the central suite database'
comsum[ 'test-db'    ] = '(ADMIN) Automated suite database test'
comsum[ 'test-suite' ] = '(ADMIN) Automated cylc scheduler test'
comsum[ 'check-examples' ] = '(ADMIN) Check all example suites validate'
# license
comsum[ 'warranty'   ] = 'Print the GPLv3 disclaimer of warranty'
comsum[ 'conditions' ] = 'Print the GNU General Public License v3.0'
# database
comsum[ 'register'   ] = 'Add a suite to your private registration database'
comsum[ 'reregister' ] = 'Change a suite\'s registered name.'
comsum[ 'alias'      ] = 'Register an alias for another registered suite'
comsum[ 'unregister' ] = 'Remove suites from the private or central database'
comsum[ 'copy'       ] = 'Copy a suite or group of suites.'
comsum[ 'print'      ] = 'Print private or central suite registrations'
comsum[ 'get-directory'    ] = 'Print a suite definition directory path'
comsum[ 'import'     ] = 'Import central registrations to your private database'
comsum[ 'export'     ] = 'Export private registrations to the central database'
comsum[ 'refresh'    ] = 'Report invalid registrations and update suite titles'
# preparation
comsum[ 'edit'       ] = 'Edit a suite.rc file in $EDITOR, optionally inlined'
comsum[ 'inline'     ] = 'View suite.rc files in $EDITOR, include-files inlined'
comsum[ 'validate'   ] = 'Parse and validate a suite config (suite.rc) file'
comsum[ 'search'     ] = 'An intelligent search tool for cylc suites'
comsum[ 'graph'      ] = 'A dependency graph viewer that updates as you edit'
comsum[ 'diff'       ] = 'Compare two suite definitions and print differences'
# information
comsum[ 'list'       ] = 'Print a suite\'s task list or full runtime hierarchy'
comsum[ 'dump'       ] = 'Print the state of each task in a running suite'
comsum[ 'show'       ] = 'Print task-specific information (prerequisites...)'
comsum[ 'log'        ] = 'Print or view suite logs, with filtering'
comsum[ 'monitor'    ] = 'An in-terminal suite monitor (see also gcylc)'
comsum[ 'get-config' ] = 'Retrieve any configuration data from a suite.'
# control
comsum[ 'gcylc'      ] = 'The cylc Graphical User Interface'
comsum[ 'run'        ] = 'Start a suite running at a specified cycle time'
comsum[ 'stop'       ] = 'Stop a suite running by various means'
comsum[ 'restart'    ] = 'Restart a suite from a previous state'
comsum[ 'trigger'    ] = 'Cause a task to trigger immediately'
comsum[ 'insert'     ] = 'Insert a task or group into a running suite'
comsum[ 'remove'     ] = 'Remove a task from a running suite'
comsum[ 'purge'      ] = 'Remove a full dependency tree from a running suite'
comsum[ 'hold'       ] = 'Put a hold on a suite or a single task'
comsum[ 'release'    ] = 'Release a  hold on a suite or a single task'
comsum[ 'block'      ] = 'Do not comply with subsequent intervention commands'
comsum[ 'unblock'    ] = 'Comply with subsequent intervention commands'
comsum[ 'reset'      ] = 'Force a task to waiting, ready, or succeeded state'
comsum[ 'nudge'      ] = 'Cause the cylc task processing loop to be invoked'
comsum[ 'depend'     ] = 'Add prerequisites to tasks on the fly'
comsum[ 'maxrunahead'   ] = 'Change the runahead limit in a running suite.'
comsum[ 'lockserver' ] = 'The cylc lockserver daemon'
comsum[ 'lockclient' ] = 'Manual suite and task lock management'
comsum[ 'verbosity'  ] = 'Change a suite\'s logging verbosity level'
# discovery
comsum[ 'ping'       ] = 'Check that a suite is running'
comsum[ 'scan'       ] = 'Scan a host for running suites and lockservers'
# task
comsum[ 'submit'     ] = 'Run a single task just as its parent suite would'
comsum[ 'started'    ] = 'Acquire a task lock and report started'
comsum[ 'message'    ] = 'Report progress and completion of outputs'
comsum[ 'succeeded'   ] = 'Release task lock and report succeeded'
comsum[ 'failed'     ] = 'Release task lock and report failure'

# utility
comsum[ 'cycletime'    ] = 'Cycle time arithmetic'
comsum[ 'checkvars'    ] = 'Check required environment variables en masse'
comsum[ 'template'     ] = 'Powerful cycle time offset filename templating'
comsum[ 'jobscript'    ] = 'Generate a task job script and print it to stdout'
comsum[ 'housekeeping' ] = 'Parallel archiving and cleanup on cycle time offsets'
comsum[ 'scp-transfer' ] = 'Scp-based file transfer for cylc suites'
comsum[ 'email-alert'  ] = 'Send alerts by email when tasks fail (for example)'

def typo( str ):
    corrected = str
    if str == 'gcycl':
        corrected = 'gcylc'
    return corrected
 
def category_help(category):
    coms = eval( category + '_commands')
    alts = '|'.join(categories[category])
    print 'CATEGORY: ' + alts + ' - ' + catsum[ category ]
    print
    print 'HELP: cylc [' + alts + '] COMMAND help,--help'
    print '  You can abbreviate ' + alts + ' and COMMAND.'
    print '  The category ' + alts + ' may be omitted.'
    print
    print 'COMMANDS:'
    pretty_print( comsum, coms, sort=True )

# no arguments: print help and exit
if len(sys.argv) == 1:
    print usage
    pretty_print( catsum, categories )
    sys.exit(1)

args = sys.argv[1:]

if '--notify-completion' in args:
    notify = True
    args.remove('--notify-completion')
else:
    notify = False

if len(args) == 1:
    if args[0] == 'categories':
        # secret argument for document processing
        keys = catsum.keys()
        keys.sort()
        for key in keys:
            print key
        sys.exit(0)
    if args[0] == 'commands':
        # secret argument for document processing
        keys = comsum.keys()
        keys.sort()
        for key in keys:
            print key
        sys.exit(0)
    if args[0].startswith( 'category=' ):
        # secret argument for gcylc
        category = args[0][9:]
        commands = eval( category + '_commands')
        for command in commands:
            print command
        sys.exit(0)
    if args[0] == 'print-cdb-dir':
        # temporary secret argument used by create-cdb
        from cylc.conf.CylcGlobals import central_regdb_dir
        print central_regdb_dir
        sys.exit(0)
    if is_help( args[0] ):
        # cylc help
        print usage
        pretty_print( catsum, categories)
        sys.exit(0)
    if ( args[0] == '-v' or args[0] == '--version' ):
        # cylc -v,--version
        print cylc_version
        sys.exit(0)

    # cylc CATEGORY with no args => category help
    try:
        category = match_dict( args[0], categories, 'CATEGORY' )
    except CommandError, x:
        # No matching category
        # print >> sys.stderr, x # (no need to print this, the exception will recur below)
        # Carry on in case of a no-argument command (e.g. 'cylc scan')
        pass
    else:
        category_help( category )
        sys.exit(0)
 
command_args = []

if len( args ) == 2 and ( is_help(args[0]) or is_help(args[1])):
    # TWO ARGUMENTS, one help
    # cylc help CATEGORY
    # cylc CATEGORY help
    # cylc help COMMAND
    # cylc COMMAND help
    if is_help( args[1] ):
        item = args[0]
    else:
        item = args[1]
    try:
        category = match_dict( item, categories, 'CATEGORY' )
    except CommandError, x:
        # no matching category, try command
        try:
            command = match_command( typo(item) )
        except CommandError, y:
            print >> sys.stderr, x
            raise SystemExit(y)
        else:
            # cylc COMMAND --help
            command_args = [ '--help' ]
    else:
        # cylc help CATEGORY
        category_help( category )
        sys.exit(0)

elif len( args ) == 3 and ( is_help(args[0]) or is_help(args[2])):
    # cylc help CATEGORY COMMAND
    # cylc CATEGORY COMMAND help
    if is_help( args[2] ):
        category = args[0]
        command = args[1]
    else:
        category = args[1]
        command = args[2]
    try:
        category = match_dict( category, categories, 'CATEGORY' )
    except CommandError, x:
        raise SystemExit(x)

    coms = eval( category + '_commands')
    try:
        command = match_dict( command, coms, category + ' COMMAND' )
    except CommandNotUniqueError, y:
        print y
        sys.exit(1)
    except CommandNotFoundError, y:
        print y
        print 'COMMANDS available in CATEGORY "' + category + '":'
        print coms.keys()
        sys.exit(1)
    
    # cylc COMMAND --help
    command_args = [ '--help' ]

else:
    # two or more args, neither of first two are help
    # cylc CATEGORY COMMAND [ARGS]
    # cylc COMMAND [ARGS]
    try:
        category = args[0]
        category = match_dict( category, categories, 'CATEGORY' )
    except CommandError, x:
        # no matching category, try command
        try:
            command = args[0]
            command = match_command( typo(command) )
        except CommandError, y:
            print >> sys.stderr, x
            raise SystemExit(y)
        else:
            # cylc COMMAND [ARGS]
            command_args = args[1:]
    else:
        # cylc CATEGORY COMMAND [ARGS]
        coms = eval( category + '_commands')
        command = args[1]
        try:
            command = match_dict( command, coms, category + ' COMMAND' )
        except CommandNotUniqueError, y:
            print y
            sys.exit(1)
        except CommandNotFoundError, y:
            print y
            print 'COMMANDS available in CATEGORY "' + category + '":'
            print coms.keys()
            sys.exit(1)
 
        else:
            # cylc COMMAND [ARGS]
            if len(args) > 1:
                command_args = args[2:]
            else:
                command_args = []

# check for help anywhere in the arg list and transform to '--help'
args_new = []
for item in command_args:
    if is_help( item ):
        args_new.append( '--help' )
    else:
        args_new.append( item )
args = args_new

# construct command to execute
# DEPRECATED TASK COMMANDS (backward compatibility):
if command in [ 'task-started', 'task-succeeded', 'task-failed', 'task-message' ]:
    command = re.sub( '^task-', '', command )

try:
    execute( [ '_' + command ] + args, notify=notify )
except KeyboardInterrupt:
    pass
